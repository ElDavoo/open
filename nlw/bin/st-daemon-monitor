#!/usr/bin/perl
# @COPYRIGHT@
use warnings;
use strict;
use FindBin;
use lib "$FindBin::Bin/../lib";
use Getopt::Long;
use Pod::Usage;
use AnyEvent;
use AnyEvent::Handle;
use Coro::AnyEvent;
use Guard qw/scope_guard/;
use Socialtext::Log qw/st_log/;

our $man = 0;
our $help = 0;
our $pidfile;
our $init_cmd;
our $max_rss = 256; # in MiB
our $max_vsz = 512; # in MiB
our $max_fds = 512;
our $signal  = 15; # SIGTERM
our $tcp_port = 0;
our $check_scgi = 0;
our $config_prefix;

GetOptions(
    'help|?' => \$help,
    man      => \$man,
    'pidfile=s' => \$pidfile,
    'init=s' => \$init_cmd,
    'sig=i'  => \$signal,
    'rss=i'  => \$max_rss,
    'vsz=i'  => \$max_vsz,
    'fds=i'  => \$max_fds,
    'tcp=i'  => \$tcp_port,
    'scgi!'  => \$check_scgi,
    'config=s' => \$config_prefix,
)
or pod2usage(-exitstatus => 1, -message => $?);
pod2usage(1) if $help;
pod2usage(-exitstatus => 0, -verbose => 2) if $man;

{
    my $update_running = `pgrep -f st-appliance-update`;
    if ($update_running ne '') {
        st_log()->debug("st-daemon-monitor: ".
            "exiting because st-appliance-update is running");
        exit 0;
    }
}

# read in the params from appliance.conf
if ($config_prefix) {
    eval "require Socialtext::Appliance::Config";
    die "Can't use appliance config: $@" if $@;

    my $conf = Socialtext::Appliance::Config->new;
    no strict "refs";
    for my $key (qw(
        pidfile init_cmd signal max_rss max_vsz max_fds tcp_port check_scgi
    )) {
        my $val = $conf->value("monitor_${config_prefix}_$key");
        next unless defined $val;
        ${"$key"} = $val;
    }
}

pod2usage(-exitstatus => 1, -message => "pidfile is required")
    unless $pidfile;
pod2usage(-exitstatus => 1, -message => "init command is required")
    unless $init_cmd;

if ($config_prefix) {
    # allow relative paths
    if ($pidfile !~ m#^/#) {
        $pidfile = "/var/run/socialtext/$pidfile";
    }
    if ($init_cmd !~ m#^/#) {
        $init_cmd = "/etc/init.d/$init_cmd";
    }
}

my ($pid) = slurp($pidfile);
$pid ||= 0;

sub slurp {
    my $filename = shift;
    local $@;
    my @lines;
    if (open(my $fh, '<', $filename)) {
        @lines = <$fh>;
        close $fh;
    }
    chomp @lines if @lines;
    return @lines;
}

sub recover {
    my $now = `/bin/date`;
    chomp $now;
    my $msg = shift;
    st_log()->error("PID=".($pid ? $pid : '?')." $msg");
    kill $signal, $pid if ($signal && $pid);
    st_log()->info("st-daemon-monitor: running $init_cmd");
    # 1 == ran init ok, 2 == init bad?
    system("$init_cmd") and exit 2;
    exit 1;
}

sub to_MiB {
    my $n = shift;
    return 0 unless $n;
    if ($n =~ s/ kB\s*//) {
        $n /= 2**10;
    }
    elsif ($n =~ s/ mB\s*//i) {
        $n = $n+0;
    }
    elsif ($n =~ s/ gB\s*//i) {
        $n *= 2**10;
    }
    elsif ($n =~ s/ tB\s*//i) {
        $n *= 2**20;
    }
    else {
        $n = 2**31; # "really big number"
    }
    return $n;
}

if (!$pid) {
    recover("can't read pidfile");
}

my $there = -d "/proc/$pid";
my @status = slurp("/proc/$pid/status") if $there;
if (!$there or !@status) {
    recover("is gone");
}
else {
    my %status = map { split(/:\s+/,$_,2) } @status;

    if ($status{State} =~ /\b(?:zombie|stopped)\b/i) {
        recover("is zombified");
    }

    if (to_MiB($status{VmRSS}) > $max_rss) {
        recover("is too big (RSS)");
    }

    if (to_MiB($status{VmSize}) > $max_vsz) {
        recover("is too big (vsize)");
    }
}

#warn "checking fds\n";

my $open_fd = eval {
    `ls /proc/$pid/fd/ 2>/dev/null | wc -l`
};

if (!$open_fd) {
    recover("is gone? can't read /proc/$pid/fd directory");
}
chomp $open_fd;

if ($open_fd > $max_fds) {
    recover("has too many files open");
}

#warn "checking port open\n";

if ($tcp_port && $tcp_port !~ /\D/) {
    my $netstat = `netstat --listening --numeric-ports -n -t | awk '{print \$4}' | egrep ':${tcp_port}\$'`;
    recover("tcp port $tcp_port is not open") unless $netstat;
}

#warn "checking scgi\n";

if ($check_scgi) {
    require Socialtext::SCGI;
    my ($err, $response) = Socialtext::SCGI->Ping($tcp_port);

    if ($err || !$response) {
        recover("scgi server isn't responding? (error: $err)");
    }
    if ($response !~ /Status: 200/sm) {
        #warn "$hdrs\n";
        recover("scgi server returned a non-200 response");
    }
}

# all's well
exit 0;

=head1 NAME

st-daemon-monitor - Monitor daemon processes

=head1 SYNOPSIS

  st-daemon-monitor --help

  st-daemon-monitor --man (Full docs?)

  st-daemon-monitor --config=proxy

  st-daemon-monitor --pidfile <Filename> --init '<Cmd>' [Options]
  

  Options:
    --sig <Int>         Signal to send before running init cmd (Default: 15)
    --rss <Int>         RSS limit
    --vsz <Int>         VSZ limit
    --fds <Int>         FDS limit
    --tcp <Port>        Check that the process is listingin on this port
    --scgi              Ping scgi server on port passed as --tcp
    --config <prefix>   Use /etc/socialtext/appliance.conf to read values

=cut
