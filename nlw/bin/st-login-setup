#!/usr/bin/perl

use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../lib";
use File::Basename qw/dirname/;
use File::Copy qw/copy move/;
use File::Path qw/mkpath/;
use List::MoreUtils qw/all/;
use Socialtext::AppConfig;
use Socialtext::Log qw/st_log/;
use Socialtext::System qw/shell_run/;
use Sys::Hostname;
use Term::ANSIColor;
use Getopt::Long;

my $VERBOSE = $ENV{VERBOSE};

if (Socialtext::AppConfig->is_appliance() && $>) {
    error("Must run this command as root.");
}

st_log->info('ST-LOGIN-SETUP: '. join(' ', @ARGV));

my $cmd = shift;
usage() unless $cmd;

my %Commands = (
    'default'     => \&default,
    'ssl'         => \&ssl,
    'client-auth' => \&client_auth,
    'help'        => \&usage,
);

my $todo = $Commands{$cmd};
error("Unknown command: '$cmd'") unless $todo;

$todo->();

exit;
################################################################################

sub default {
    my $port;
    GetOptions('http-port=s'=>\$port);

    update_config(
        credentials_extractors => 'BasicAuth:Cookie:Guest',
        challenger             => 'STLogin',
        ssl_only               => 0,
        ($port ? (custom_http_port=>$port) : ()),
    );

    clear_ssl_files();
    reconfigure();
    success();
}

sub ssl {
    with_ssl_setup(
        needed_certs => [qw/key cert/],
        configs => {
            credentials_extractors => 'BasicAuth:Cookie:Guest',
            challenger             => 'STLogin',
        },
        switches => {
            optional => sub {my $v=shift; return (ssl_only => !$v);},
        },
    );
}

sub client_auth {
    with_ssl_setup(
        needed_certs => [qw/key cert ca/],
        configs => {
            credentials_extractors => 'SSLCertificate:Guest',
            challenger             => 'NoLogin',
            ssl_only               => 1,
        },
        more => {
            message => sub {
                my $msg = shift;
                if ($msg) {
                    error("Message file '$msg' does not exist") unless -f $msg;
                }
                return (login_message_file => $msg);
            },
        },
    );
}

sub with_ssl_setup {
    my %param = @_;
    my $needed   = delete $param{needed_certs};
    my $switches = delete $param{switches} || {};
    my $more     = delete $param{more} || {};
    my $configs  = delete $param{configs} || {};

    my $collated = collate_certs($needed);

    my $certs = $collated->{needed};
    my $on_off = { map { $_ => '' } keys %$switches };
    my $addtl = {map { $_ => '' } keys %$more},
    my ($http_port,$https_port); # these are always optional.
    GetOptions(
        'https-port=s' => \$https_port,
        'http-port=s'  => \$http_port,
        (map { $_."=s" => \$certs->{$_} } keys %$certs),
        (map { $_ => \$on_off->{$_} } keys %$on_off),
        (map { $_."=s" => \$addtl->{$_} } keys %$addtl),
    );

    error("Cannot find required certs\n.. Try `$0 help` for more.")
        unless all { $certs->{$_} && -f $certs->{$_} } keys %$certs;

    # Hard to express simply, but $switches->{$_} returns a coderef
    # that takes one arg, $on_off->{$_}. The ref munges that code into
    # a key/value pair that can be passed to update_config.
    my %options = map { $switches->{$_}->($on_off->{$_}) } keys %$switches;
    my %addtl = map { $more->{$_}->($addtl->{$_}) } keys %$more;

    update_config(
        %$configs,
        %options,
        %addtl,
        ($http_port ? (custom_http_port=>$http_port) : ()),
        ($https_port ? (ssl_port=>$https_port) : ()),
    );

    my @to_clear = keys %{$collated->{excluded}};
    clear_ssl_files(@to_clear) if @to_clear;
    write_ssl_files(%$certs);
    reconfigure();
    success();
}

sub collate_certs {
    my $needed = shift;
    my $all = list_ssl_files();
   
    my %mapped = map { $_ => 1 } @$needed;
    my $collated = {needed => {}, excluded => {}};
    for my $ix (keys %$all) {
        my $key = $mapped{$ix} ? 'needed' : 'excluded';
        $collated->{$key}{$ix} = $all->{$ix};
    }

    return $collated;
}

sub clear_ssl_files {
    my @ixs = @_;
    my $files = list_ssl_files();

    my $appliance = Socialtext::AppConfig->is_appliance;
    my @to_clear = @ixs ? @ixs : keys %$files;
    for my $ix (@to_clear) {
        my $v = $files->{$ix};
        next unless -f $v;

        message("Clear SSL: '$ix' => '$v'", 'magenta') if $VERBOSE;
        message("$v will be regenerated, so this is a no-op", 'yellow')
            unless $appliance || $ix eq 'ca';

        move($v, "$v.old");
    }
}

sub write_ssl_files {
    my %param = @_;
    my $files = list_ssl_files();

    for my $ix (keys %param) {
        my $src  = $param{$ix};
        my $dest = $files->{$ix};

        if ($src eq $dest) { # file is already in place.
            message("Write SSL: skipping '$ix' => '$dest'", 'magenta') if $VERBOSE;
            next;
        }
        error("No SSL destination for $src ($ix)") unless $dest;

        message("Write SSL: '$ix' => '$dest'", 'magenta') if $VERBOSE;
        mkpath(dirname($dest)) unless -d dirname($dest);
        copy($src, $dest) or error("Copy: $src => $dest: $!");
    }
}

sub list_ssl_files {
    my @ixs = @_;

    my $config = Socialtext::AppConfig->new();
    my $path = $config->is_appliance
        ? '/etc/ssl' : $ENV{HOME} . '/.nlw/etc/ssl';
    my $name = $config->web_hostname;

    my $ssl_files = {
        cert => "$path/certs/$name.crt",
        key  => "$path/private/$name.key",
        ca   => "$path/certs/$name.client.crt",
    };

    my @to_list = @ixs ? @ixs : keys %$ssl_files;
    return {
        map { $_ => $ssl_files->{$_} } @to_list
    };
}

sub update_config {
    my %to_update = @_;

    my $config = Socialtext::AppConfig->new();
    for my $ix (keys %to_update) {
        my $v = $to_update{$ix};
        message("Update Config: '$ix' => '$v'", 'magenta') if $VERBOSE;
        $config->set($ix, $to_update{$ix});
    }
    $config->write();
}

sub success {
    my $restart = Socialtext::AppConfig->is_appliance()
        ? 'sudo st-appliance-ctl' : 'nlwctl';

    message("\nDone. Run `$restart restart` to restart services.\n", 'green');
}

sub reconfigure {
    if (Socialtext::AppConfig->is_appliance()) {
        shell_run('dpkg-reconfigure st-webserver');
    }
    else { # dev-env
        shell_run('gen-config');
    }
}

sub error {
    my $error = shift;
    message("Error: $error", 'red');
    exit 1;
}

sub message {
    my $message = shift;
    my $color = shift;

    print color($color) if $color;
    print "$message\n";
    print color('reset') if $color;
}

sub usage {
    print <<EOT;
  USAGE: $0 command [command options]

  st-login-setup is a command that can be used to simplify the appliance's
  login process. There are many steps involved in configuring your appliance's
  login, using this tool can oftentimes reduce things into a simple call.

  COMMANDS

    default: The simplest setup. Standard HTTP logins; this is how your
        appliance is set up by default. Accepts an optional `--http-port`
        parameter.

    ssl: Configures your appliance to run with SSL set up. Accepts a required
        (most of the time) `--key` and `--cert` parameter, as well as optional
        `--http-port`, `--https-port` and `--optional` parameters.

    client-auth: Configure your appliance to with SSL set up. Additionally,
        clients, eg web-browsers, will need to provide a certificate in order
        to authenticate themselves. Accepts a required (most of the time)
        `--key` and `--cert` parameter, as well as optional `--http-port`,
        `--https-port` and `--optional` and `--message` parameters.

    help: What you are reading now.

   OPTIONS

     --http-port: The port that your HTTP server will run on. This is
         completely optional and no ports will be changed if this is not passed.
         When using an SSL-only setup, all this changes is the HTTP port that
         will redirect to HTTPS.

     --https-port: This port that your HTTPS server will run on. This is not
         used in the `default` command. This is completely optional and will
         not change anything if it is not passed.

     --optional: This will make SSL optional on your appliance. This is used
         only in the `ssl` command and, if passed, will configure your machine
         to run on both HTTP and HTTPS ports.

     --message: Set a custom "Login Disabled" message using a file on the
         system. The file used should be an HTML snippe. This is available for
         only the `client-auth` command. If the param is not passed, we will
         use the default login disabled message.

     --key: The path to the key file for your HTTPS certificate. This file will
         be copied into place. This is available for the `ssl` and
         `client-auth` commands. If you do not pass this param to the command,
         we will assume you'd like to use the key file that is already in
         place, otherwise we will exit the operation with an error.

     --cert: The path to your HTTPS certificate file. This file will be copied
         into place. This is available for the `ssl` and `client-auth`
         commands. Like `--key`, we will try to use and existing file if this
         parameter is not passed.

     --ca: The path to the signing certificate for your Client-Side certs. This
         file will be copied into place. This is available for only the
         `client-auth` command. Like `--key`, we will try to use and existing
         file if this parameter is not passed.

   ENVIRONMENT VARIABLES

      VERBOSE: Setting this to 1 will increase the verbosity of your output.

EOT
    exit;
}
