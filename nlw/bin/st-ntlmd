#!/usr/bin/perl
use warnings;
use strict;

use AnyEvent;
use Socialtext::Async::HTTPD qw/http_server/;

package mod_perl;
our $VERSION = 0.01;

package Apache::ConnectionAddr;

package Apache::Connection;
our $AUTOLOAD;
sub import {}
sub AUTOLOAD {
    use Data::Dumper; warn "Autoload Apache::Connection $AUTOLOAD".Dumper(@_);
    return '';
}

sub DESTROY {}
sub remote_addr {}
use constant remote_host => '127.0.0.1';
use constant remote_port => '0bogus';

package Apache::Table;
use Moose;
use MooseX::AttributeHelpers;

has '_table' => (is => 'rw', isa => 'HashRef',
    default => sub {{}},
    metaclass => 'Collection::Hash',
    provides => {
        get => 'get',
        set => 'add',
    }
);

package Apache;
use Moose;
use MooseX::AttributeInflate;
our $AUTOLOAD;
sub import {}

has '_sid' => (is => 'rw', isa => 'Str');
has '_dir_config' => (is => 'rw', isa => 'Apache::Table', lazy_build => 1);
has_inflated 'err_headers_out' => (is => 'rw', isa => 'Apache::Table');
has_inflated 'headers_in' => (
    is => 'rw', isa => 'Apache::Table',
    handles => {
        header_in => 'get',
    }
);
has_inflated 'headers_out' => (is => 'rw', isa => 'Apache::Table');
has 'uri' => (is => 'rw', isa => 'Str');
has 'user' => (is => 'rw', isa => 'Str');

sub AUTOLOAD {
    use Data::Dumper; warn "Autoload Apache $AUTOLOAD ".Dumper([caller,@_]);
    return '';
}

sub connection {
    my $self = shift;
    my $sid = $self->_sid . '';
    return bless \$sid, 'Apache::Connection';
}

sub _build__dir_config {
    return Apache::Table->new(_table => {
            ntdomain => 'foo bar baz',
    });
}

sub dir_config {
    my $self = shift;
    my $k = shift;
    if (!$k) {
        return $self->_dir_config;
    }
    return $self->_dir_config->get($k);
}

sub log_reason {
    my $self = shift;
    warn $_[0].$/;
}

use constant auth_type => 'ntlm,basic';
use constant auth_name => '';
use constant proxyreq => 0;

package Apache::Constants;
use constant OK => 'OK';
use constant DECLINED => 'DECLINED';
use constant HTTP_UNAUTHORIZED => 401;
use constant HTTP_FORBIDDEN => 403;
use constant HTTP_INTERNAL_SERVER_ERROR => 500;
our $AUTOLOAD;
sub import {}
sub AUTOLOAD {
    use Data::Dumper; die "Autoload Apache::Constants $AUTOLOAD".Dumper(@_);
}

package Apache::File;
our $AUTOLOAD;
sub import {}
sub AUTOLOAD {
    use Data::Dumper; die "Autoload Apache::File $AUTOLOAD".Dumper(@_);
}

package main;

use Socialtext::NTLM::Config;
use Apache::AuthenNTLM;

my $orig_get_config = \&Apache::AuthenNTLM::get_config;
{
    no warnings 'redefine';
    *Apache::AuthenNTLM::sockaddr_in = sub {
        return '127.0.0.1', '0bogus';
    };
    *Apache::AuthenNTLM::get_config = \&main::get_config;
}

sub get_config {
    my ($self, $r) = @_;

    # if we've already read in the config, don't do it again.
    return if ($self->{smbpdc});

    $orig_get_config->($self,$r);

    $self->{debug} = 1;

    delete $self->{smbpdc}{foo};
    delete $self->{smbbdc}{foo};

    # force Apache::AuthenNTLM to split up the "domain\username" and only
    # leave us the "username" part; our Authen system doesn't understand
    # composite usernames and isn't able to handle this as an exception to the
    # rule.
    $self->{splitdomainprefix} = 1;

    # read in our NTLM config, and set up our PDC/BDCs
    my @all_configs = Socialtext::NTLM::Config->load();
    foreach my $config (@all_configs) {
        my $domain  = lc( $config->domain() );
        my $primary = $config->primary();
        my $backups = $config->backup();

        $self->{smbpdc}{$domain} = $primary;
        $self->{smbbdc}{$domain} = join ' ', @{$backups};
    }

    # set the default/fallback domains, in case the NTLM handshake doesn't
    # indicate which one to use
    $self->{defaultdomain}  = Socialtext::NTLM::Config->DefaultDomain();
    $self->{fallbackdomain} = Socialtext::NTLM::Config->FallbackDomain();

    # debugging notes
    my $prefix = 'ST::Apache::Authen::NTLM:';
    warn( "$prefix default domain: " . $self->{defaultdomain} );
    warn( "$prefix fallback domain: " . $self->{fallbackdomain} );
    warn( "$prefix AuthType: " . $self->{authtype} );
    warn( "$prefix AuthName: " . $self->{authname} );
    warn( "$prefix Auth NTLM: " . $self->{authntlm} );
    warn( "$prefix Auth Basic: " . $self->{authbasic} );
    warn( "$prefix NTLMAuthoritative: " . $self->{ntlmauthoritative} );
    warn( "$prefix SplitDomainPrefix: " . $self->{splitdomainprefix} );
    foreach my $domain (sort keys %{$self->{smbpdc}}) {
        next unless ($domain);  # skip blank/empty domains
        warn( "$prefix domain: $domain" );
        warn( "$prefix ... pdc: " . $self->{smbpdc}{$domain} );
        warn( "$prefix ... bdc: " . $self->{smbbdc}{$domain} );
    }
}

# TODO: make this an LRU cache
my %cache_cache;

my $server = http_server '127.0.0.1', '9090', sub {
    my ($handle, $env, undef, $err, $fatal) = @_;

    my ($sid) = ($env->{QUERY_STRING} =~ /sid=([^;&]+)/);
    unless ($sid) {
        $handle->push_write("HTTP/1.0 500 No session\r\nContent-Length:0\r\n\r\n");
        $handle->on_drain(sub {
            shutdown $handle->{fh}, 1;
            $handle->destroy;
        });
        return;
    }
    warn "STARTING SID: $sid\n";
    warn "... AUTH HDR: ".$env->{HTTP_X_AUTHORIZATION}."\n"
        if ($env->{HTTP_X_AUTHORIZATION});

    # "reconnect" the session
    warn "... EXISTS!\n" if $cache_cache{$sid};
    $Apache::AuthenNTLM::cache = $cache_cache{$sid};

    my $r = Apache->new(_sid => $sid);
    $r->uri($env->{PATH_INFO});
    $r->headers_in(Apache::Table->new(_table => {
        Connection => 'keep-alive',
        'Authorization' => $env->{HTTP_X_AUTHORIZATION},
    }));

    my $rc = Apache::AuthenNTLM -> run($r);

    # keep the session for later
    $cache_cache{$sid} = $Apache::AuthenNTLM::cache;

    my $resp = "HTTP/1.0 200 OK\r\n".
        "X-Status: $rc\r\n";

    if (my $w_a = $r->err_headers_out->get('WWW-Authenticate')) {
        $resp .= "X-WWW-Authenticate: $w_a\r\n";

        # for Basic, there's no need to keep a session
        delete $cache_cache{$sid}
            if ($w_a =~ /^Basic /i);
    }
    elsif (my $u = $r->user) {
        $resp .= "X-User: $u\r\n";
        # got a user, therefore done with this session.
        delete $cache_cache{$sid};
    }

    $resp .=
        "Content-Length: 2\r\n".
        "Content-Type: text/plain\r\n".
        "ok\r\n";

    warn "RESPONSE: $resp";
    warn "CACHED: ".scalar(keys %cache_cache)."\n";
    $handle->push_write($resp);
    $handle->on_drain(sub {
        shutdown $handle->{fh}, 1;
        $handle->destroy;
    });
};

AE::cv->recv;
