#!/usr/bin/perl
use warnings;
use strict;

use AnyEvent;
use Guard;
use Socialtext::Async::HTTPD qw/http_server/;

package mod_perl;
our $VERSION = 0.01;

package Apache::Connection;
# Caution: this class is a blessed Int, not a hashref

sub remote_addr {}
use constant remote_host => '127.0.0.1';
use constant remote_ip => '127.0.0.1';
use constant remote_port => '0bogus';

package Apache::Table;
use Moose;
use MooseX::AttributeHelpers;

has '_table' => (is => 'rw', isa => 'HashRef',
    default => sub {{}},
    metaclass => 'Collection::Hash',
    provides => {
        get => 'get',
        set => 'add',
    }
);

package Apache;
use Moose;
use MooseX::AttributeInflate;
our $AUTOLOAD;
sub import {}

has '_sid' => (is => 'rw', isa => 'Str');

has '_dir_config' => (is => 'rw', isa => 'Apache::Table', lazy_build => 1);
has_inflated 'err_headers_out' => (is => 'rw', isa => 'Apache::Table');
has_inflated 'headers_in' => (
    is => 'rw', isa => 'Apache::Table',
    handles => {
        header_in => 'get',
    }
);
has_inflated 'headers_out' => (is => 'rw', isa => 'Apache::Table');
has 'uri' => (is => 'rw', isa => 'Str');
has 'user' => (is => 'rw', isa => 'Str');

# only support ntlm, not Basic
has 'authtype' => (is => 'rw', isa => 'Str', default => 'ntlm');

sub AUTOLOAD {
    use Data::Dumper; warn "Autoload Apache $AUTOLOAD ".Dumper([caller,@_]);
    return '';
}

sub connection {
    my $self = shift;
    my $con = 42;
    return bless \$con, 'Apache::Connection';
}

sub _build__dir_config {
    return Apache::Table->new(_table => {
        ntdomain => 'foo bar baz',
        ntlmdebug => 0,
        ntlmsemkey => 0, # disable IPC::Semaphore locking
    });
}

sub dir_config {
    my $self = shift;
    my $k = shift;
    if (!$k) {
        return $self->_dir_config;
    }
    return $self->_dir_config->get($k);
}

sub log_reason {
    my $self = shift;
    warn $_[0].$/;
}

use constant auth_type => 'ntlm,basic';
use constant auth_name => '';
use constant proxyreq => 0;

package Apache::Constants;
use constant OK => 'OK';
use constant DECLINED => 'DECLINED';
use constant HTTP_UNAUTHORIZED => 401;
use constant HTTP_FORBIDDEN => 403;
use constant HTTP_INTERNAL_SERVER_ERROR => 500;
our $AUTOLOAD;
sub import {}
sub AUTOLOAD {
    use Data::Dumper; die "Autoload Apache::Constants $AUTOLOAD".Dumper(@_);
}

package Apache::File;
our $AUTOLOAD;
sub import {}
sub AUTOLOAD {
    use Data::Dumper; die "Autoload Apache::File $AUTOLOAD".Dumper(@_);
}

package main;

use Socialtext::NTLM::Config;
use Apache::AuthenNTLM;

my $orig_get_config = \&Apache::AuthenNTLM::get_config;
{
    no warnings 'redefine';
    *Apache::AuthenNTLM::sockaddr_in = sub {
        return '127.0.0.1', '0bogus';
    };
    *Apache::AuthenNTLM::get_config = \&main::get_config;

    # paranoia: disable the IPC::Semaphore stuff
    *Apache::AuthenNTLM::Lock::lock = sub { 'dummy' };
    *Apache::AuthenNTLM::Lock::DESTROY = sub {};
}

sub get_config {
    my ($self, $r) = @_;

    # if we've already read in the config, don't do it again.
    return if ($self->{smbpdc});

    $orig_get_config->($self,$r);

    $self->{debug} = 1;

    # mocking sets up these two:
    delete $self->{smbpdc}{foo};
    delete $self->{smbbdc}{foo};

    # force Apache::AuthenNTLM to split up the "domain\username" and only
    # leave us the "username" part; our Authen system doesn't understand
    # composite usernames and isn't able to handle this as an exception to the
    # rule.
    $self->{splitdomainprefix} = 1;

    # read in our NTLM config, and set up our PDC/BDCs
    my @all_configs = Socialtext::NTLM::Config->load();
    foreach my $config (@all_configs) {
        my $domain  = lc( $config->domain() );
        my $primary = $config->primary();
        my $backups = $config->backup();

        $self->{smbpdc}{$domain} = $primary;
        $self->{smbbdc}{$domain} = join ' ', @{$backups};
    }

    # set the default/fallback domains, in case the NTLM handshake doesn't
    # indicate which one to use
    $self->{defaultdomain}  = Socialtext::NTLM::Config->DefaultDomain();
    $self->{fallbackdomain} = Socialtext::NTLM::Config->FallbackDomain();

    # debugging notes
#     my $prefix = 'ST::Apache::Authen::NTLM:';
#     warn( "$prefix default domain: " . $self->{defaultdomain} );
#     warn( "$prefix fallback domain: " . $self->{fallbackdomain} );
#     warn( "$prefix AuthType: " . $self->{authtype} );
#     warn( "$prefix AuthName: " . $self->{authname} );
#     warn( "$prefix Auth NTLM: " . $self->{authntlm} );
#     warn( "$prefix Auth Basic: " . $self->{authbasic} );
#     warn( "$prefix NTLMAuthoritative: " . $self->{ntlmauthoritative} );
#     warn( "$prefix SplitDomainPrefix: " . $self->{splitdomainprefix} );
#     foreach my $domain (sort keys %{$self->{smbpdc}}) {
#         next unless ($domain);  # skip blank/empty domains
#         warn( "$prefix domain: $domain" );
#         warn( "$prefix ... pdc: " . $self->{smbpdc}{$domain} );
#         warn( "$prefix ... bdc: " . $self->{smbbdc}{$domain} );
#     }
}

my $in_progress_sid;
my $in_progress_timer;

our $Reconnect_timeout = 2.0;

my $pending_guard;
my $pending_reqs = [];

my $port = 9090; # TODO: getopt
warn "Starting server on port $port\n";
my $server = http_server '127.0.0.1', $port, sub {
    my ($handle, $env, undef, $err, $fatal) = @_;

    # TODO; react to err/fatal

    my ($sid) = ($env->{QUERY_STRING} =~ /sid=([^;&]+)/);
    unless ($sid) {
        $handle->push_write("HTTP/1.0 500 No session\r\n".
            "Content-Length:0\r\n\r\n");
        $handle->on_drain(sub {
            shutdown $handle->{fh}, 1;
            $handle->destroy;
        });
        return;
    }
    my $xa = $env->{HTTP_X_AUTHORIZATION} || '';
    my $ntlm_type = ($xa !~ /NTLM .{7}TUAA(.)/) ? 'non-ntlm' :
        ($1 eq 'B') ? 'type 1' : 'type 3';
    warn "GOT SID: $sid, NTLM type: $ntlm_type\n";

    if ($ntlm_type eq 'non-ntlm') {
        ask_to_use_ntlm($handle);
        return;
    }

    if (!$in_progress_sid) {
        warn "NEW SID $sid\n";
    }
    elsif ($sid eq $in_progress_sid) {
        warn "CONTINUE $sid\n";
        undef $in_progress_timer; # cancel the timeout
    }
    else {
        warn "QUEUE $sid\n";
        push @$pending_reqs, [$handle, $env, $sid];
        return;
    }

    do_ntlm($handle,$env,$sid);
    return;
};

sub ask_to_use_ntlm {
    my $handle = shift;
    warn "client didn't provide a NTLM blob, rc: 401\n";
    my $resp =
        "HTTP/1.0 200 OK\r\n".
        "X-Status: 401\r\n".
        "X-WWW-Authenticate: NTLM\r\n".
        "Content-Length: 3\r\n".
        "Content-Type: text/plain\r\n".
        "\r\n".
        "ok\n";
    $handle->push_write($resp);
    $handle->on_drain(sub {
        shutdown $handle->{fh}, 1;
        $handle->destroy;
    });
    return;
}

sub empty_pending {
    warn "empty pending queue\n";
    $pending_reqs = [];
    undef $pending_guard;
}

sub cancel_in_progress {
    warn "throwing out sid $in_progress_sid\n";
    undef $Apache::AuthenNTLM::cache; # releases samba
    undef $in_progress_sid;
    undef $in_progress_timer; # and ourselves

    unless (@$pending_reqs) {
        empty_pending();
        return;
    }

    # schedule processing the next pending request
    $pending_guard ||= AE::idle(sub {
        if (!@$pending_reqs) {
            empty_pending();
            return;
        }
        warn "found pending\n";

        # might be unnecessary paranoia:
        if ($in_progress_sid) {
            # disable guard, leave queue alone; timer will clean up the
            # in-progress one if needed.
            undef $pending_guard;
            return;
        }

        my $next = shift @$pending_reqs;
        do_ntlm(@$next);
    });
}

sub do_ntlm {
    my ($handle, $env, $sid) = @_;

    warn "PROCESSING SID: $sid\n";

    my $r = Apache->new(
        _sid => $sid,
        uri => $env->{PATH_INFO},
        headers_in => Apache::Table->new(_table => {
            Connection    => 'keep-alive',
            Authorization => $env->{HTTP_X_AUTHORIZATION},
        })
    );

    # blocks, blocks HARD:
    my $rc = Apache::AuthenNTLM -> run($r);

    my $resp = "HTTP/1.0 200 OK\r\n".
        "X-Status: $rc\r\n";

    my $w_a = $r->err_headers_out->get('WWW-Authenticate');
    my $u = $r->user || '';
    if ($w_a) {
        $resp .= "X-WWW-Authenticate: $w_a\r\n";
        # stop processing the queue while we're working on this one.
        undef $pending_guard;
        $in_progress_sid = $sid;
        $in_progress_timer =
            AE::timer $Reconnect_timeout, 0, sub {
                warn "TIMEOUT $sid\n";
                cancel_in_progress();
            };
    }
    elsif ($u) {
        $resp .= "X-User: $u\r\n";
        # all finished
        cancel_in_progress();
    }

    $resp .=
        "Content-Length: 3\r\n".
        "Content-Type: text/plain\r\n".
        "\r\n".
        "ok\n";

    warn "RESPONSE to $sid: rc: $rc, x-www-a: ".($w_a ? 'yes' : 'no').", user: $u\n";
    $handle->on_error(sub {
        cancel_in_progress();
        $handle->destroy;
    });
    $handle->push_write($resp);
    $handle->on_drain(sub {
        shutdown $handle->{fh}, 1;
        $handle->destroy;
    });
};

AE::cv->recv;
