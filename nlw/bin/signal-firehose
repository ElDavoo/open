#!/usr/bin/perl
use strict;
use warnings;
use FindBin;
use EV;
use AnyEvent;
use lib "$FindBin::Bin/../firehose-lib/lib/perl5";
use lib "$FindBin::Bin/../lib";
use Socialtext::SQL qw/get_dbh sql_execute sql_singlevalue/;
use Fatal qw/mkdir link/;
use Socialtext::Signal;
use Data::Dumper;
use Socialtext::UserSetContainer;
use Socialtext::JSON qw/encode_json/;
use Socialtext::UserSet ':all';
use Socialtext::Timer qw/time_scope/;
use AnyEvent::HTTPD;
use Socialtext::HTTP::Cookie;

sub say { print(@_, "\n") }

# Polls signals DB, sends updates to connected users
# TODO:
# * Hide user_set_ids that the receiving user should not see
# * Show all signals from "public" groups (defined in config)
# ** This would allow better client-side filtering of groups
# * Figure out how to make database polling non-blocking
# * don't poll the DB when we just did X msec ago

my $main_cv = AE::cv();
my $dbh = get_dbh();

# This query could become more advanced over time. For now, just grab all
# signals.
my $sth = $dbh->prepare(<<EOSQL);
    SELECT $Socialtext::Signal::SIGNAL_FIELDS, signal.at
    FROM signal 
    $Socialtext::Signal::USER_SET_IDS_JOIN
    WHERE at > ?::timestamptz
    ORDER BY signal.at ASC
EOSQL


# These users have open connections:
my %active_users;

# This maps account IDs to the indirect member user_ids
# No attempt is made to keep this current.
my %acct_users;

# Collect some global stats for easier debugging
my %stats;
my $stats_ticker = AE::timer 15, 15, sub { say Dumper \%stats };


my $last_db_request = sql_singlevalue(q{select 'now'::timestamptz});
my $database_ticker = sub {
    $stats{"database polls"}++;
    $sth->execute($last_db_request) || die "execute failed: " . $sth->errstr;

    my $results = $sth->fetchall_arrayref({});
    my %send_to_these_people;
    while (my $sig = shift @$results) {
        $stats{"Signals found"}++;
        $last_db_request = $sig->{at};

        my ($users, $groups, undef, $accts) = 
            user_set_id_partition($sig->{user_set_ids});
        for my $acct_id (@$accts) {
            unless ($acct_users{$acct_id}) {
                say "Loading users in account $acct_id";
                $acct_users{$acct_id} = users_in_uset($acct_id + ACCT_OFFSET);
            }

            for my $uid (@{ $acct_users{$acct_id}}) {
                next unless $active_users{$uid};
                $send_to_these_people{$uid}++;
                push @{ $active_users{$uid}{queued} }, $sig;
                say "Queued $sig->{signal_id} for user $uid";
            }
        }
    }
    for my $uid (keys %send_to_these_people) {
        my $u = $active_users{$uid};
        my $req = delete $active_users{$uid}{req};
        next unless defined $req;

        say "Sending " . 0+@{$u->{queued}} . " signals to $uid";
        $req->respond({ content => ['application/json', encode_json($u->{queued}). "\n"] });
        $u->{queued} = [];

        # Set up a timer to drop this user.
        $u->{timeout} = AE::timer 10, 0, sub {
            my $now = time();
            if ($now - $u->{connected_at} >= 10) {
                say "User $uid has not connected in a while, dropping them.";
                delete $active_users{$uid};
            }
            else {
                say "User $uid has had recent activity, they can stay!";
            }
        };
    }
};

# Poll the DB every 5 seconds (blocking).
my $database_ticker_timer = AE::timer 5, 5, $database_ticker;

my $port = (shift(@ARGV) || Socialtext::HTTP::Ports->firehose_port()) or die "Usage: $0 <port>\n";
say "Starting HTTPD server at http://localhost:$port";

my $httpd = AnyEvent::HTTPD->new(port => $port, host => '127.0.0.1');
$httpd->reg_cb (
   '/data/firehose/signals' => sub {
      my ($httpd, $req) = @_;

      my $uid = _get_user_id_from_cookie($req) or return;
      if (my $u = $active_users{$uid}) {
          say "User re-connected: $uid";
          $u->{req} = $req;
          $u->{connected_at} = time;
          $u->{timeout} = undef;
      }
      else {
          say "New user connected: $uid";
          $active_users{$uid} = {
              req => $req,
              connected_at => time(),
              queued => [],
              timeout => undef,
          };
      }
   },

   # Someone suggests we check the database.
   '/data/firehose/tick' => sub {
       my ($httpd, $req) = @_;
       say "Tick!";
       $stats{Tick}++;
       $req->respond({ content => ['text/plain', "Thank you.\n"] });
       $database_ticker->();
       $httpd->stop_request;
   },
);

say "Starting main event loop";
$main_cv->recv; # run forever
exit;

sub _get_user_id_from_cookie {
    my $req = shift;
    my $headers = $req->headers;
    my $cookie_string = $headers->{cookie};
    my @cookies = split /\b; \b/, $cookie_string;
    for my $c (@cookies) {
        my ($name, $value) = split /=/, $c, 2;
        next unless $name eq 'NLW-user';

        say "Splitting '$value'";
        my %user_data = split /[&;]|\b; \b/, $value;
        my $uid = $user_data{user_id};

        my $expected_MAC = Socialtext::HTTP::Cookie->MAC_for_user_id($uid);
        if ($expected_MAC ne $user_data{MAC}) {
            $req->respond ({ content => ['text/plain', "Bad cookie\n" ] });
            return;
        }
        return $uid;
    }
    $req->respond ({ content => ['text/plain', "No cookie\n" ] });
    return;
}

sub users_in_uset {
    my $uset = shift;

    $stats{"users in uset"}++;
    my $t = time_scope 'users_in_uset';
    my $id_filter = PG_USER_FILTER;
    my $sth = sql_execute(qq{
        SELECT DISTINCT from_set_id
        FROM user_set_path
        WHERE from_set_id $id_filter
          AND into_set_id = ?
    }, $uset);
    return [ map { $_->[0] } @{$sth->fetchall_arrayref || []} ];
}

