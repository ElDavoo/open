#!/usr/bin/perl
use strict;
use warnings;
use FindBin;
use EV;
use AnyEvent;
use lib "$FindBin::Bin/../firehose-lib/lib/perl5";
use lib "$FindBin::Bin/../lib";
use Socialtext::SQL qw/get_dbh sql_execute sql_singlevalue/;
use Fatal qw/mkdir link/;
use Socialtext::Signal;
use YAML;;
use Socialtext::UserSetContainer;
use Socialtext::JSON qw/encode_json/;
use Socialtext::UserSet ':all';
use Socialtext::Timer qw/time_scope/;
use AnyEvent::HTTPD;
use Socialtext::HTTP::Cookie ':constants';

sub say { print(@_, "\n") }

# Polls signals DB, sends updates to connected users
# TODO:
# * Show all signals from "public" groups (defined in config)
# ** This would allow better client-side filtering of groups
# * Figure out how to make database polling non-blocking
# * don't poll the DB when we just did X msec ago

my $main_cv = AE::cv();
my $dbh = get_dbh();

# This query could become more advanced over time. For now, just grab all
# signals.
my $sth = $dbh->prepare(<<EOSQL);
    SELECT $Socialtext::Signal::SIGNAL_FIELDS, signal.at
    FROM signal 
    $Socialtext::Signal::USER_SET_IDS_JOIN
    WHERE at > ?::timestamptz
    ORDER BY signal.at ASC
EOSQL


# These users have open connections:
my %active_users;

# This maps account IDs to the indirect member user_ids
# No attempt is made to keep this current.
my %acct_users;
my %group_users;

# Collect some global stats for easier debugging
my %stats;
my $stats_ticker = AE::timer 15, 15, sub { say YAML::Dump(\%stats), '---' };

use Socialtext::User;
use Socialtext::Signal;
use Socialtext::Rest::Signals;

{ # Preparing a "convert_signal_by_uid_to_resource" utility function.
    my $_active_uid;
    my $_rest_signals = bless(
        { rest => bless({}, '__mock__') },
        'Socialtext::Rest::Signals'
    );

    sub __mock__::user {
        return Socialtext::User->new(user_id => $_active_uid);
    }

    sub convert_signal_by_uid_to_resource {
        my $signal = shift;
        $_active_uid = shift;
        return $_rest_signals->convert_signal_to_resource($signal);
    }
};

my $last_signal_response_time = time();
my $last_db_request = sql_singlevalue(q{select 'now'::timestamptz});
my $database_ticker = sub {
    $stats{"database polls"}++;
    $sth->execute($last_db_request) || die "execute failed: " . $sth->errstr;

    my $results = $sth->fetchall_arrayref({});
    my %send_to_these_people;
    while (my $sig = shift @$results) {
        $stats{"Signals found"}++;
        $last_db_request = $sig->{at};

        my ($users, $groups, undef, $accts) = 
            user_set_id_partition($sig->{user_set_ids});
        $sig->{group_ids} = $groups;
        $sig->{account_ids} = $accts;

        my %recips;
        for my $acct_id (@$accts) {
            unless ($acct_users{$acct_id}) {
                say "Loading users in account $acct_id";
                $acct_users{$acct_id} = users_in_uset($acct_id + ACCT_OFFSET);
            }

            for my $uid (@{ $acct_users{$acct_id}}) {
                next unless $active_users{$uid};
                $recips{$uid}++;
            }
        }
        for my $group_id (@$groups) {
            unless ($group_users{$group_id}) {
                say "Loading users in group $group_id";
                $group_users{$group_id} = users_in_uset($group_id + GROUP_OFFSET);
            }

            for my $uid (@{ $group_users{$group_id}}) {
                next unless $active_users{$uid};
                $recips{$uid}++;
            }
        }

        for my $uid (keys %recips) {
            # Render each Signal once, on behalf of the receiving user.
            my $resource = convert_signal_by_uid_to_resource(
                Socialtext::Signal->_db_fields_to_object({ %$sig }),
                $uid
            );

            $send_to_these_people{$uid}++;
            push @{ $active_users{$uid}{queued} }, $resource;
            say "Queued $sig->{signal_id} for user $uid";
        }
    }

    $last_signal_response_time = time();

    for my $uid (keys %send_to_these_people) {
        my $u = $active_users{$uid};
        my $req = delete $active_users{$uid}{req};
        next unless defined $req;

        say "Sending " . (0+@{$u->{queued}}) . " signals to $uid";
        $req->respond({ content => ['application/json', encode_json($u->{queued}). "\n"] });
        $u->{queued} = [];

        # Set up a timer to drop this user (10 minutes).
        $u->{timeout} = AE::timer 600, 0, sub {
            # If nobody has spoken in 10 minutes, don't erroneously drop everybody.
            return if $u->{connected_at} >= $last_signal_response_time;

            my $now = time();
            if ($now - $u->{connected_at} >= 600) {
                say "User $uid has not connected in a while, dropping them.";
                delete $active_users{$uid};
            }
            else {
                say "User $uid has had recent activity, they can stay!";
            }
        };
    }
};

# Poll the DB every second (blocking).
my $database_ticker_timer = AE::timer 1, 1, $database_ticker;

my $port = (shift(@ARGV) || Socialtext::HTTP::Ports->firehose_port()) or die "Usage: $0 <port>\n";
say "Starting HTTPD server at http://localhost:$port";

my $httpd = AnyEvent::HTTPD->new(port => $port, host => '127.0.0.1');
$httpd->reg_cb (
   '/data/firehose/signals' => sub {
      my ($httpd, $req) = @_;

      my $uid = _get_user_id_from_cookie($req) or return;
      if (my $u = $active_users{$uid}) {
          say "User re-connected: $uid";
          $u->{req} = $req;
          $u->{connected_at} = time;
          $u->{timeout} = undef;
      }
      else {
          say "New user connected: $uid";
          $active_users{$uid} = {
              req => $req,
              connected_at => time(),
              queued => [],
              timeout => undef,
          };
      }
   },

   # Someone suggests we check the database.
   '/data/firehose/tick' => sub {
       my ($httpd, $req) = @_;
       say "Tick!";
       $stats{Tick}++;
       $req->respond({ content => ['text/plain', "Thank you.\n"] });
       $database_ticker->();
       $httpd->stop_request;
   },
);

say "Starting main event loop";
$main_cv->recv; # run forever
exit;

sub _get_user_id_from_cookie {
    my $req = shift;
    my $headers = $req->headers;
    my $cookie_string = $headers->{cookie};
    my @cookies = split /\b; \b/, $cookie_string;
    for my $c (@cookies) {
        my ($name, $value) = split /=/, $c, 2;
        next unless $name eq USER_DATA_COOKIE
                 or $name eq AIR_USER_COOKIE;

        say "Splitting '$value'";
        my %user_data = split /[&;]|\b; \b/, $value;
        my $uid = $user_data{user_id};

        my $expected_MAC = Socialtext::HTTP::Cookie->MAC_for_user_id($uid);
        if ($expected_MAC ne $user_data{MAC}) {
            $req->respond ({ content => ['text/plain', "Bad cookie\n" ] });
            return;
        }
        return $uid;
    }
    $req->respond ({ content => ['text/plain', "No AIR/NLW user cookie found, please log-in first.\n" ] });
    return;
}

sub users_in_uset {
    my $uset = shift;

    $stats{"users in uset"}++;
    my $t = time_scope 'users_in_uset';
    my $id_filter = PG_USER_FILTER;
    my $sth = sql_execute(qq{
        SELECT DISTINCT from_set_id
        FROM user_set_path
        WHERE from_set_id $id_filter
          AND into_set_id = ?
    }, $uset);
    my $user_ids = [ map { $_->[0] } @{$sth->fetchall_arrayref || []} ];
    say "Found " . (0+@$user_ids) . " users in user_set $uset";
    return $user_ids;
}

