AttachmentIndex.pm:4:use namespace::clean -except => 'meta';
AttachmentIndex.pm:11:    my $args = $self->arg;
AttachmentIndex.pm:12:    my $indexer = $self->indexer
AttachmentIndex.pm:15:    my $page = eval { $self->page };
AttachmentIndex.pm:16:    # this should be done in the builder for ->page, but just in case:
AttachmentIndex.pm:17:    unless ($page && $page->exists) {
AttachmentIndex.pm:18:        $self->permanent_failure(
AttachmentIndex.pm:19:            "No page $args->{page_id} in workspace $args->{workspace_id}\n"
AttachmentIndex.pm:24:    $indexer->index_attachment( $args->{page_id}, $args->{attach_id} );
AttachmentIndex.pm:26:    $self->completed();
AttachmentIndex.pm:29:__PACKAGE__->meta->make_immutable;
Test.pm:6:use namespace::clean -except => 'meta';
Test.pm:25:    my $args = $self->arg;
Test.pm:27:    die "failed!\n" if $args->{fail};
Test.pm:29:    st_log->debug($args->{message})      if $args->{message};
Test.pm:30:    sleep $args->{sleep}                 if $args->{sleep};
Test.pm:31:    st_log->debug($args->{post_message}) if $args->{post_message};
Test.pm:34:    if ($args->{get_workspace}) {
Test.pm:35:        my $ws = $self->workspace;
Test.pm:36:        st_log->debug("Workspace: ".$ws->name);
Test.pm:38:    if ($args->{get_page}) {
Test.pm:39:        my $page = $self->page;
Test.pm:40:        st_log->debug("Page ".$page->title);
Test.pm:42:    if ($args->{get_indexer}) {
Test.pm:43:        my $indexer = $self->indexer;
Test.pm:44:        st_log->debug("Indexer OK");
Test.pm:47:    $Last_ID = $self->job->jobid;
Test.pm:49:    $self->completed();
Test.pm:52:__PACKAGE__->meta->make_immutable;
Cmd.pm:6:use namespace::clean -except => 'meta';
Cmd.pm:14:    my $cmd = $self->arg->{cmd};
Cmd.pm:15:    my $args = $self->arg->{args} || [];
Cmd.pm:16:    my $timeout = $self->arg->{timeout} || 10;
Cmd.pm:21:        $self->failed($output,$?);
Cmd.pm:24:        $self->completed($output);
Cmd.pm:28:__PACKAGE__->meta->make_immutable;
EmailNotify.pm:4:use namespace::clean -except => 'meta';
EmailNotify.pm:10:    return $self->workspace->email_notify_is_enabled;
EmailNotify.pm:20:    my $prefs = $self->hub->preferences->new_for_user($user->email_address);
EmailNotify.pm:21:    return $prefs->{notify_frequency}->value * 60;
EmailNotify.pm:25:    return $self->workspace->users;
EmailNotify.pm:30:    my $page = $self->page or return;
EmailNotify.pm:31:    my $ws = $self->workspace or return;
EmailNotify.pm:32:    my $hub = $self->hub;
EmailNotify.pm:34:    my $t = $self->arg->{modified_time};
EmailNotify.pm:37:    my $ws_id = $ws->workspace_id;
EmailNotify.pm:39:    return $self->completed unless $self->workspace->email_notify_is_enabled;
EmailNotify.pm:41:    return $self->completed if $page->is_system_page;
EmailNotify.pm:43:    return $self->completed unless $page->is_recently_modified;
EmailNotify.pm:45:    $hub->log->info( "Sending recent changes notifications from ".$ws->name );
EmailNotify.pm:48:    my $users = $self->_get_applicable_users();
EmailNotify.pm:49:    my $job_class = $self->_user_job_class;
EmailNotify.pm:50:    while (my $user = $users->next) {
EmailNotify.pm:51:        my $user_id = $user->user_id;
EmailNotify.pm:52:        $hub->current_user($user);
EmailNotify.pm:53:        my $freq = $self->_freq_for_user($user);
EmailNotify.pm:57:        my $job = TheSchwartz::Moosified::Job->new(
EmailNotify.pm:59:            priority => -64,
EmailNotify.pm:61:            uniqkey => "$ws_id-$user_id",
EmailNotify.pm:70:    $hub->log->info("Creating " . scalar(@jobs) . " new $job_class jobs");
EmailNotify.pm:72:    $self->job->client->insert($_) for @jobs;
EmailNotify.pm:73:    $self->completed;
EmailNotify.pm:76:__PACKAGE__->meta->make_immutable;
PageIndex.pm:4:use namespace::clean -except => 'meta';
PageIndex.pm:11:    my $page    = $self->page or return;
PageIndex.pm:12:    my $indexer = $self->indexer or return;
PageIndex.pm:14:    $indexer->index_page($page->id);
PageIndex.pm:16:    $self->completed();
PageIndex.pm:19:__PACKAGE__->meta->make_immutable;
Upgrade/MigrateUserWorkspacePrefs.pm:6:use namespace::clean -except => 'meta';
Upgrade/MigrateUserWorkspacePrefs.pm:13:    my $path = Socialtext::Paths::user_directory($self->workspace->name);
Upgrade/MigrateUserWorkspacePrefs.pm:14:    Socialtext::Workspace::Importer->Import_user_workspace_prefs($path, $self->workspace);
Upgrade/MigrateUserWorkspacePrefs.pm:16:    $self->completed();
Upgrade/MigrateUserWorkspacePrefs.pm:19:__PACKAGE__->meta->make_immutable;
Upgrade/MigrateNotifyPrefs.pm:7:use namespace::clean -except => 'meta';
Upgrade/MigrateNotifyPrefs.pm:13:Socialtext::Job::Upgrade::MigrateNotifyPrefs - migrate email & watchlist notify state
Upgrade/MigrateNotifyPrefs.pm:21:Migrates data from disk into the new schwartz-based notifier system.  Deletes
Upgrade/MigrateNotifyPrefs.pm:30:    my $ws   = $self->workspace;
Upgrade/MigrateNotifyPrefs.pm:33:    return $self->completed unless $ws->email_notify_is_enabled;
Upgrade/MigrateNotifyPrefs.pm:35:    return $self->completed unless $ws->real;
Upgrade/MigrateNotifyPrefs.pm:37:    my $path = Socialtext::Paths::user_directory($ws->name);
Upgrade/MigrateNotifyPrefs.pm:38:    my $plugin_dir = Socialtext::Paths::plugin_directory($ws->name);
Upgrade/MigrateNotifyPrefs.pm:46:            my $user = Socialtext::User->new(email_address => $email);
Upgrade/MigrateNotifyPrefs.pm:49:            $self->_schedule_notify_job($user, $pref_key, $last_email)
Upgrade/MigrateNotifyPrefs.pm:50:                if ($user && $ws->real);
Upgrade/MigrateNotifyPrefs.pm:61:            if (-d $d) {
Upgrade/MigrateNotifyPrefs.pm:73:        # last e-mail run time for a workspace
Upgrade/MigrateNotifyPrefs.pm:82:        next unless -f $strange_file;
Upgrade/MigrateNotifyPrefs.pm:86:    $self->completed();
Upgrade/MigrateNotifyPrefs.pm:95:    my $ws_id = $self->workspace->workspace_id;
Upgrade/MigrateNotifyPrefs.pm:96:    my $user_id = $user->user_id;
Upgrade/MigrateNotifyPrefs.pm:98:    my $prefs = $self->hub->preferences->new_for_user($user->email_address);
Upgrade/MigrateNotifyPrefs.pm:99:    my $freq = $prefs->{$pref_key}->value;
Upgrade/MigrateNotifyPrefs.pm:103:    my $now = $self->job->insert_time;
Upgrade/MigrateNotifyPrefs.pm:108:    if (($now - $window_end) > WINDOW_LIMIT) {
Upgrade/MigrateNotifyPrefs.pm:110:        $pages_after = $now - WINDOW_LIMIT;
Upgrade/MigrateNotifyPrefs.pm:121:    my $job = TheSchwartz::Moosified::Job->new(
Upgrade/MigrateNotifyPrefs.pm:123:        priority => -64,
Upgrade/MigrateNotifyPrefs.pm:125:        uniqkey => "$ws_id-$user_id",
Upgrade/MigrateNotifyPrefs.pm:133:    $self->job->client->insert($job);
Upgrade/MigrateNotifyPrefs.pm:136:__PACKAGE__->meta->make_immutable;
Upgrade/EnableSocialcalc.pm:5:use namespace::clean -except => 'meta';
Upgrade/EnableSocialcalc.pm:11:Socialtext::Job::Upgrade::EnableSocialcalc - enable socialcalc
Upgrade/EnableSocialcalc.pm:26:    Socialtext::Workspace->EnablePluginForAll('socialcalc');
Upgrade/EnableSocialcalc.pm:28:    $self->completed();
Upgrade/EnableSocialcalc.pm:31:__PACKAGE__->meta->make_immutable;
Upgrade/RebuildPageLinks.pm:8:use namespace::clean -except => 'meta';
Upgrade/RebuildPageLinks.pm:15:# Re-parsing all the content for each page can take a long time, so
Upgrade/RebuildPageLinks.pm:22:    my $ws   = $self->workspace or return;
Upgrade/RebuildPageLinks.pm:23:    my $hub  = $self->hub or return;
Upgrade/RebuildPageLinks.pm:25:    return $self->completed unless $ws->real;
Upgrade/RebuildPageLinks.pm:27:    my $ws_name = $ws->name;
Upgrade/RebuildPageLinks.pm:28:    $self->hub->log->info("Rebuilding page links for workspace: $ws_name");
Upgrade/RebuildPageLinks.pm:30:    my @pages = $self->hub->pages->all;
Upgrade/RebuildPageLinks.pm:31:    my $pm = Parallel::ForkManager->new(1);
Upgrade/RebuildPageLinks.pm:34:    $pm->run_on_finish( sub {
Upgrade/RebuildPageLinks.pm:37:            $self->hub->log->error("Core dump while parsing $ws_name/$id")
Upgrade/RebuildPageLinks.pm:50:            $pm->start($page->id) and next;
Upgrade/RebuildPageLinks.pm:52:            my $links = Socialtext::PageLinks->new(hub => $hub, page => $page);
Upgrade/RebuildPageLinks.pm:53:            $links->update;
Upgrade/RebuildPageLinks.pm:55:            $pm->finish;
Upgrade/RebuildPageLinks.pm:57:        $pm->wait_all_children;
Upgrade/RebuildPageLinks.pm:59:        my $dir = Socialtext::PageLinks->WorkspaceDirectory($ws_name);
Upgrade/RebuildPageLinks.pm:60:        if ($dir and -d $dir) {
Upgrade/RebuildPageLinks.pm:62:                next unless -f $file;
Upgrade/RebuildPageLinks.pm:64:                    or $self->hub->log->error(
Upgrade/RebuildPageLinks.pm:67:            rmdir $dir or $self->hub->log->error(
Upgrade/RebuildPageLinks.pm:71:    $self->hub->log->error($@) if $@;
Upgrade/RebuildPageLinks.pm:73:    # Need to explicitly re-connect the DBH after we disconnected it earlier.
Upgrade/RebuildPageLinks.pm:74:    $self->job->dbh(get_dbh());
Upgrade/RebuildPageLinks.pm:75:    $self->completed();
Upgrade/RebuildPageLinks.pm:78:__PACKAGE__->meta->make_immutable;
Upgrade/RebuildPageLinks.pm:83:Socialtext::Job::Upgrade::RebuildPageLinks - Rebuild a workspace's page links
Upgrade/RebuildPageLinks.pm:89:    Socialtext::JobCreator->insert(
Upgrade/ReindexPeople.pm:5:use namespace::clean -except => 'meta';
Upgrade/ReindexPeople.pm:11:    my $ws   = $self->workspace or return;
Upgrade/ReindexPeople.pm:12:    my $hub  = $self->hub or return;
Upgrade/ReindexPeople.pm:16:        my $factory = Socialtext::Search::Solr::Factory->new;
Upgrade/ReindexPeople.pm:17:        my $indexer = $factory->create_indexer();
Upgrade/ReindexPeople.pm:18:        $indexer->delete_people();
Upgrade/ReindexPeople.pm:21:        Socialtext::People::Profile->IndexPeople();
Upgrade/ReindexPeople.pm:23:    $self->hub->log->error($@) if $@;
Upgrade/ReindexPeople.pm:25:    $self->completed();
Upgrade/ReindexPeople.pm:28:__PACKAGE__->meta->make_immutable;
Upgrade/ReindexPeople.pm:33:Socialtext::Job::Upgrade::ReindexPeople - Delete people from Solr & reindex
Upgrade/ReindexPeople.pm:39:    Socialtext::JobCreator->insert(
Upgrade/ReindexSignals.pm:7:use namespace::clean -except => 'meta';
Upgrade/ReindexSignals.pm:13:    my $ws   = $self->workspace or return;
Upgrade/ReindexSignals.pm:14:    my $hub  = $self->hub or return;
Upgrade/ReindexSignals.pm:18:        my $factory = Socialtext::Search::Solr::Factory->new;
Upgrade/ReindexSignals.pm:19:        my $indexer = $factory->create_indexer();
Upgrade/ReindexSignals.pm:20:        $indexer->delete_signals();
Upgrade/ReindexSignals.pm:26:        while (my $row = $sth->fetchrow_arrayref) {
Upgrade/ReindexSignals.pm:27:            my $signal = Socialtext::Signal->Get(signal_id => $row->[0]);
Upgrade/ReindexSignals.pm:28:            Socialtext::JobCreator->index_signal($signal, priority => 60);
Upgrade/ReindexSignals.pm:31:    $self->hub->log->error($@) if $@;
Upgrade/ReindexSignals.pm:33:    $self->completed();
Upgrade/ReindexSignals.pm:36:__PACKAGE__->meta->make_immutable;
Upgrade/ReindexSignals.pm:41:Socialtext::Job::Upgrade::ReindexSignals - Delete signals from Solr & reindex
Upgrade/ReindexSignals.pm:47:    Socialtext::JobCreator->insert(
WatchlistNotify.pm:5:use namespace::clean -except => 'meta';
WatchlistNotify.pm:16:    my $prefs = $self->hub->preferences->new_for_user($user->email_address);
WatchlistNotify.pm:17:    return $prefs->{watchlist_notify_frequency}->value * 60;
WatchlistNotify.pm:25:    return Socialtext::Watchlist->Users_watching_page(
WatchlistNotify.pm:26:        $self->workspace->workspace_id, $self->page->id,
WatchlistNotify.pm:30:__PACKAGE__->meta->make_immutable;
WeblogPing.pm:5:use namespace::clean -except => 'meta';
WeblogPing.pm:11:    my $page = $self->page or return;
WeblogPing.pm:13:    Socialtext::WeblogUpdates->new(hub => $page->hub)->send_ping($page);
WeblogPing.pm:15:    $self->completed();
WeblogPing.pm:18:__PACKAGE__->meta->make_immutable;
SignalDMNotify.pm:9:use namespace::clean -except => 'meta';
SignalDMNotify.pm:15:    my $args = $self->arg;
SignalDMNotify.pm:16:    my $signal = Socialtext::Signal->Get(signal_id => $self->arg->{signal_id});
SignalDMNotify.pm:17:    my $sender = $signal->user;
SignalDMNotify.pm:18:    my $recipient = $signal->recipient;
SignalDMNotify.pm:19:    my $webroot = $args->{webroot};
SignalDMNotify.pm:21:    my $renderer = Socialtext::TT2::Renderer->instance();
SignalDMNotify.pm:22:    my $paths = $self->hub->skin->template_paths;
SignalDMNotify.pm:23:    push @$paths, Socialtext::AppConfig->code_base . "/plugin/signals/template";
SignalDMNotify.pm:25:    my $parser = Socialtext::WikiText::Parser::Messages->new(
SignalDMNotify.pm:26:        receiver => Socialtext::WikiText::Emitter::Messages::HTML->new(
SignalDMNotify.pm:33:    my $signal_html  = $parser->parse($signal->body);
SignalDMNotify.pm:36:    my $html_body = $renderer->render(
SignalDMNotify.pm:37:        template => 'email/direct-message.html',
SignalDMNotify.pm:49:    my $email_sender = Socialtext::EmailSender::Factory->create($locale);
SignalDMNotify.pm:50:    $email_sender->send(
SignalDMNotify.pm:51:        from      => $sender->name_and_email,
SignalDMNotify.pm:52:        to        => $recipient->name_and_email,
SignalDMNotify.pm:53:        subject   => loc("Private message from [_1]", $sender->best_full_name),
SignalDMNotify.pm:57:    $self->completed();
SignalDMNotify.pm:60:__PACKAGE__->meta->make_immutable;
WebHook.pm:8:use namespace::clean -except => 'meta';
WebHook.pm:15:    my $ua = LWP::UserAgent->new;
WebHook.pm:16:    $ua->agent('Socialtext/WebHook');
WebHook.pm:18:    my $args = $self->arg;
WebHook.pm:19:    my $payload = ref($args->{payload}) ? encode_json($args->{payload})
WebHook.pm:20:                                        : $args->{payload};
WebHook.pm:24:        print $fh "URI: $args->{hook}{url}\n$payload\n\n";
WebHook.pm:28:        my $response = $ua->post( $args->{hook}{url},
WebHook.pm:31:        st_log()->info("Triggered webhook '$args->{hook}{id}': "
WebHook.pm:32:                        . $response->status_line);
WebHook.pm:35:    $self->completed();
WebHook.pm:38:__PACKAGE__->meta->make_immutable;
EmailNotifyUser.pm:7:use namespace::clean -except => 'meta';
EmailNotifyUser.pm:15:    my $user = $self->user or return;
EmailNotifyUser.pm:16:    my $ws   = $self->workspace or return;
EmailNotifyUser.pm:17:    my $hub  = $self->hub or return;
EmailNotifyUser.pm:19:    return $self->completed
EmailNotifyUser.pm:20:        unless $ws->real && $ws->email_notify_is_enabled;
EmailNotifyUser.pm:22:    return $self->completed
EmailNotifyUser.pm:23:        unless defined $user->email_address
EmailNotifyUser.pm:24:            && length $user->email_address
EmailNotifyUser.pm:25:            && !$user->requires_confirmation();
EmailNotifyUser.pm:27:    return $self->completed unless $ws->has_user($user);
EmailNotifyUser.pm:31:    my $pages = $self->_pages_to_send;
EmailNotifyUser.pm:33:    return $self->completed unless $pages && @$pages;
EmailNotifyUser.pm:35:    my $prefs = $hub->preferences->new_for_user($user->email_address);
EmailNotifyUser.pm:36:    $pages = $self->_sort_pages_for_user($user, $pages, $prefs);
EmailNotifyUser.pm:38:    my $tz = $hub->timezone;
EmailNotifyUser.pm:39:    my $email_time = $tz->_now();
EmailNotifyUser.pm:44:        include_editor   => $self->_links_only($prefs),
EmailNotifyUser.pm:45:        email_time       => $tz->get_time_user($email_time) ,
EmailNotifyUser.pm:46:        email_date       => $tz->get_dateonly_user($email_time) ,
EmailNotifyUser.pm:48:        $self->_extra_template_vars(),
EmailNotifyUser.pm:52:        my $notifier = Socialtext::EmailNotifier->new();
EmailNotifyUser.pm:53:        $notifier->send_notifications(
EmailNotifyUser.pm:57:            from  => $ws->formatted_email_notification_from_address,
EmailNotifyUser.pm:58:            $self->_notification_vars,
EmailNotifyUser.pm:61:    $self->hub->log->error($@) if $@;
EmailNotifyUser.pm:63:    my @clone_args = map { $_ => $self->job->$_ }
EmailNotifyUser.pm:66:    my $next_interval_job = TheSchwartz::Moosified::Job->new({
EmailNotifyUser.pm:68:        run_after => $pages_fetched_at + $self->_frequency_pref($prefs),
EmailNotifyUser.pm:70:            %{$self->arg},
EmailNotifyUser.pm:75:    $self->job->replace_with($next_interval_job);
EmailNotifyUser.pm:80:        chrono  => sub { $b->age_in_seconds <=> $a->age_in_seconds },
EmailNotifyUser.pm:81:        reverse => sub { $a->age_in_seconds <=> $b->age_in_seconds },
EmailNotifyUser.pm:82:        default => sub { $a->id cmp $b->id },
EmailNotifyUser.pm:91:        my $sort_order = $prefs->sort_order->value;
EmailNotifyUser.pm:103:    my $ws = $self->workspace;
EmailNotifyUser.pm:106:        subject => loc('Recent Changes In [_1] Workspace', $ws->title),
EmailNotifyUser.pm:107:        text_template => 'email/recent-changes.txt',
EmailNotifyUser.pm:108:        html_template => 'email/recent-changes.html',
EmailNotifyUser.pm:115:        grep { !$_->is_system_page }
EmailNotifyUser.pm:116:            $self->hub->pages->all_at_or_after($self->arg->{pages_after})
EmailNotifyUser.pm:123:        preference_uri   => $self->workspace->uri . 'emailprefs',
EmailNotifyUser.pm:130:    return $prefs->links_only->value eq 'condensed' ? 0 : 1;
EmailNotifyUser.pm:136:    return $prefs->{notify_frequency}->value * 60;
EmailNotifyUser.pm:139:__PACKAGE__->meta->make_immutable;
WatchlistNotifyUser.pm:6:use namespace::clean -except => 'meta';
WatchlistNotifyUser.pm:12:    my $ws = $self->workspace;
WatchlistNotifyUser.pm:15:        subject => loc('Watchlist update for [_1] Workspace', $ws->title),
WatchlistNotifyUser.pm:23:    my $pages = $self->hub->pages;
WatchlistNotifyUser.pm:25:    my $wl = Socialtext::Watchlist->new(
WatchlistNotifyUser.pm:26:        user      => $self->user,
WatchlistNotifyUser.pm:27:        workspace => $self->workspace,
WatchlistNotifyUser.pm:29:    my @page_ids = $wl->pages(new_as => $self->arg->{pages_after});
WatchlistNotifyUser.pm:32:        grep { !$_->is_system_page }
WatchlistNotifyUser.pm:33:        map { $pages->new_page($_) }
WatchlistNotifyUser.pm:41:        preference_uri   => $self->workspace->uri . 'watchlistprefs',
WatchlistNotifyUser.pm:48:    return $prefs->watchlist_links_only->value eq 'condensed' ? 0 : 1;
WatchlistNotifyUser.pm:54:    return $prefs->{watchlist_notify_frequency}->value * 60;
WatchlistNotifyUser.pm:57:__PACKAGE__->meta->make_immutable;
GroupRefresh.pm:5:use namespace::clean -except => 'meta';
GroupRefresh.pm:22:    my $group_id = $self->arg->{group_id};
GroupRefresh.pm:25:        Socialtext::Group->GetProtoGroup( { group_id => $group_id } );
GroupRefresh.pm:29:        $self->permanent_failure( $msg );
GroupRefresh.pm:38:    my $proto         = $self->proto_group;
GroupRefresh.pm:44:    # clear the in-memory Group cache, so we *know* we're going to the DB
GroupRefresh.pm:46:    Socialtext::Group->cache->clear();
GroupRefresh.pm:49:    Socialtext::Group->GetGroup( { group_id => $proto->{group_id} } );
GroupRefresh.pm:51:    $self->completed();
GroupRefresh.pm:54:__PACKAGE__->meta->make_immutable;
GroupRefresh.pm:59:Socialtext::Job::GroupRefresh - Refresh an LDAP group cache.
GroupRefresh.pm:65:    Socialtext::JobCreator->insert(
AccountInvite.pm:7:use namespace::clean -except => 'meta';
AccountInvite.pm:23:    return Socialtext::User->new( user_id => $self->arg->{sender_id} );
AccountInvite.pm:28:    return Socialtext::Account->new( account_id => $self->arg->{account_id} );
AccountInvite.pm:34:    my $account = $self->account;
AccountInvite.pm:35:    my $user    = $self->user;
AccountInvite.pm:37:    unless ( $account->has_user($user) ) {
AccountInvite.pm:38:        my $msg = "User " . $user->user_id 
AccountInvite.pm:39:            . " is not in account " . $account->account_id;
AccountInvite.pm:40:        return $self->failed($msg, 255);
AccountInvite.pm:44:        my $invitation = Socialtext::AccountInvitation->new(
AccountInvite.pm:46:            from_user   => $self->sender,
AccountInvite.pm:47:            extra_text  => $self->arg->{extra_text},
AccountInvite.pm:50:        # {bz: 3357} - Somehow the constructor does not set layout of $invitation
AccountInvite.pm:51:        # properly; manually re-assign the fields until we get a cycle to investigate.
AccountInvite.pm:52:        $invitation->{from_user} = $self->sender;
AccountInvite.pm:53:        $invitation->{extra_text} = $self->arg->{extra_text};
AccountInvite.pm:55:        $invitation->invite_notify($user);
AccountInvite.pm:58:        return $self->failed($e, 255);
AccountInvite.pm:61:    $self->completed();
AccountInvite.pm:65:__PACKAGE__->meta->make_immutable;
AccountInvite.pm:70:Socialtext::Job::AccountInvite - Send an invite to a user for an account.
AccountInvite.pm:76:    Socialtext::JobCreator->insert(
AccountInvite.pm:87:Schedule a job to be run by TheCeq which will send an e-mail message to the
Delay/LongLived.pm:6:use namespace::clean -except => 'meta';
Delay/LongLived.pm:14:    my $delay = $self->arg->{'sleep'} || 10;
Delay/LongLived.pm:15:    st_log->debug("start long-lived job");
Delay/LongLived.pm:17:    st_log->debug("finish long-lived job");
Delay/LongLived.pm:18:    $self->completed();
Delay/LongLived.pm:21:__PACKAGE__->meta->make_immutable;
Delay/LongLived.pm:26:Socialtext::Job::Delay::LongLived - Test/sample Long-Lived Job
Delay/LongLived.pm:32:  Socialtext::JobCreator->insert(
Delay/LongLived.pm:40:of the available Workers (so that long-running Jobs don't inadvertently clog
Delay/ShortLived.pm:6:use namespace::clean -except => 'meta';
Delay/ShortLived.pm:14:    my $delay = $self->arg->{'sleep'} || 0.2;
Delay/ShortLived.pm:15:    st_log->debug("start short-lived job");
Delay/ShortLived.pm:17:    st_log->debug("finish short-lived job");
Delay/ShortLived.pm:18:    $self->completed();
Delay/ShortLived.pm:21:__PACKAGE__->meta->make_immutable;
Delay/ShortLived.pm:26:Socialtext::Job::Delay::ShortLived - Test/sample Short-Lived Job
Delay/ShortLived.pm:32:  Socialtext::JobCreator->insert(
SignalIndex.pm:4:use namespace::clean -except => 'meta';
SignalIndex.pm:11:    my $indexer = $self->indexer or return;
SignalIndex.pm:12:    my $signal_id = $self->arg->{signal_id};
SignalIndex.pm:13:    my $signal  = $self->signal;
SignalIndex.pm:16:        $indexer->index_signal($signal);
SignalIndex.pm:19:        $indexer->delete_signal($signal_id);
SignalIndex.pm:22:    $self->completed();
SignalIndex.pm:25:__PACKAGE__->meta->make_immutable;
SignalIndex.pm:30:Socialtext::Job::SignalIndex - index a signal.
SignalIndex.pm:36:    Socialtext::JobCreator->index_signal($signal);
PersonIndex.pm:4:use namespace::clean -except => 'meta';
PersonIndex.pm:11:    my $indexer = $self->indexer or return;
PersonIndex.pm:13:    $indexer->index_person($self->user);
PersonIndex.pm:15:    $self->completed();
PersonIndex.pm:18:__PACKAGE__->meta->make_immutable;
PersonIndex.pm:23:Socialtext::Job::PersonIndex - index a person profile.
PersonIndex.pm:29:    Socialtext::JobCreator->index_person($user);
WorkspaceInvite.pm:7:use namespace::clean -except => 'meta';
WorkspaceInvite.pm:23:    return Socialtext::User->new( user_id => $self->arg->{sender_id} );
WorkspaceInvite.pm:28:    return Socialtext::Workspace->new(
WorkspaceInvite.pm:29:        workspace_id => $self->arg->{workspace_id},
WorkspaceInvite.pm:36:    my $workspace = $self->workspace;
WorkspaceInvite.pm:37:    my $user    = $self->user;
WorkspaceInvite.pm:39:    unless ( $workspace->has_user($user) ) {
WorkspaceInvite.pm:40:        my $msg = "User " . $user->user_id 
WorkspaceInvite.pm:41:            . " is not in workspace " . $workspace->workspace_id;
WorkspaceInvite.pm:42:        $self->failed($msg, 255);
WorkspaceInvite.pm:46:        my $invitation = Socialtext::WorkspaceInvitation->new(
WorkspaceInvite.pm:48:            from_user   => $self->sender,
WorkspaceInvite.pm:49:            extra_text  => $self->arg->{extra_text},
WorkspaceInvite.pm:52:        # {bz: 3357} - Somehow the constructor does not set layout of $invitation
WorkspaceInvite.pm:53:        # properly; manually re-assign the fields until we get a cycle to investigate.
WorkspaceInvite.pm:54:        $invitation->{from_user} = $self->sender;
WorkspaceInvite.pm:55:        $invitation->{extra_text} = $self->arg->{extra_text};
WorkspaceInvite.pm:57:        $invitation->invite_notify($user);
WorkspaceInvite.pm:60:        $self->failed($e, 255);
WorkspaceInvite.pm:63:    $self->completed();
WorkspaceInvite.pm:67:__PACKAGE__->meta->make_immutable;
WorkspaceInvite.pm:72:Socialtext::Job::WorkspaceInvite - Send an invite to a user for a workspace.
WorkspaceInvite.pm:78:    Socialtext::JobCreator->insert(
WorkspaceInvite.pm:89:Schedule a job to be run by TheCeq which will send an e-mail message to the
GroupInvite.pm:7:use namespace::clean -except => 'meta';
GroupInvite.pm:23:    return Socialtext::User->new( user_id => $self->arg->{sender_id} );
GroupInvite.pm:28:    return Socialtext::Group->GetGroup( driver_unique_id => $self->arg->{group_id} );
GroupInvite.pm:33:    my $group = $self->group;
GroupInvite.pm:34:    my $user  = $self->user;
GroupInvite.pm:36:    unless ( $group->has_user($user) ) {
GroupInvite.pm:37:        my $msg = "User " . $user->user_id 
GroupInvite.pm:38:            . " is not in group " . $group->group_id;
GroupInvite.pm:39:        $self->failed($msg, 255);
GroupInvite.pm:43:        my $invitation = Socialtext::GroupInvitation->new(
GroupInvite.pm:45:            from_user  => $self->sender,
GroupInvite.pm:46:            extra_text => $self->arg->{extra_text},
GroupInvite.pm:49:        # {bz: 3357} - Somehow the constructor does not set layout of $invitation
GroupInvite.pm:50:        # properly; manually re-assign the fields until we get a cycle to investigate.
GroupInvite.pm:51:        $invitation->{from_user} = $self->sender;
GroupInvite.pm:52:        $invitation->{extra_text} = $self->arg->{extra_text};
GroupInvite.pm:54:        $invitation->invite_notify($user);
GroupInvite.pm:57:        $self->failed($e, 255);
GroupInvite.pm:60:    $self->completed();
GroupInvite.pm:64:__PACKAGE__->meta->make_immutable;
GroupInvite.pm:69:Socialtext::Job::GroupInvite - Send an invite to a user for an group.
GroupInvite.pm:75:    Socialtext::JobCreator->insert(
GroupInvite.pm:86:Schedule a job to be run by TheCeq which will send an e-mail message to the
