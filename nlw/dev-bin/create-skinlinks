#!/usr/bin/perl
# @COPYRIGHT@
use strict;
use warnings;
use Cwd;
use File::Basename qw(basename dirname);
use File::Find::Rule;
use File::Spec;
use Getopt::Long;

#############################################################################
# Defaults
my $DEFAULT_SKIN_CHECKOUT = "$ENV{HOME}/src/st/customer-skins";
my $DEFAULT_DEV_ENV       = "$ENV{HOME}/src/st/current/nlw";
my @DEFAULT_SKIN_SUBDIRS  = qw(css images javascript);

#############################################################################
# Command Line Parsing and Setup
my %OPTS;
GetOptions(
    \%OPTS,
    "dir|d=s",
    "branch|b=s",
    "all|a",
    "skin|s=s",
    "update|u",
    "examples",
    "help|h",
) or exit_with_usage("Failed to parse command line");

# SETUP DEFAULT VALUES
$OPTS{skin} = shift @ARGV unless defined $OPTS{skin};
$OPTS{dir} = $DEFAULT_SKIN_CHECKOUT unless defined $OPTS{dir};

# VALIDATE THE COMMAND LINE
exit_with_usage("Usage Information") if $OPTS{help};
exit_with_examples() if defined $OPTS{examples};
$OPTS{all} = 1 unless defined $OPTS{skin};  # --all is the default action

#############################################################################
# Main
my @skins = get_skins_to_link( $OPTS{all}, $OPTS{dir}, 
                               $OPTS{branch}, $OPTS{skin} );
update_checkout(@skins) if $OPTS{update};
for my $skin (@skins) {
    link_skin($skin);
}
exit 0;

#############################################################################
# Main Subroutines.  The cod eto drive the main section above.

# List get_skins_to_link(Bool all, String dir, String branch, String skin)
#
# Return a list of absolute paths to the skins we're going to link.  If all is
# given then all the skins we can find are returned, otherwise just the skin
# specified by $skin.  If branch is undef then we look in $dir/trunk first,
# otherwise we look in just $dir.  If a valid base directory can't be found,
# or if no skins are found, or if a specific skin can't be found then an error
# is thrown.
sub get_skins_to_link {
    my ( $all, $dir, $branch, $skin ) = @_;
    my $skin_base = get_base_skin_dir( $dir, $branch );
    return get_skin_path( $skin_base, $skin ) unless $all;
    my @paths = grep is_valid_skin_path($_),
                     File::Find::Rule->directory()->in($skin_base);
    return @paths if @paths;
    die "No skins found in $skin_base!  Perhaps you should supply --dir?\n";
}

# void update_checkout(List @skins)
#
# The @skins list is a list of paths to skins.  If there is more than one than
# we try to be smart about our update by first finding all the common parent
# directories and updating those instead.  This means for N skins, all with
# one common base dir, there is just one update rather than N.  However, if
# there is just one skin then we just update that skin's directory directly,
# and not it's parent directory since that might update more than the user
# wants.
sub update_checkout {
    my @skins = @_;
    my @dirs = ( @skins > 1 ) ? find_common_base_dirs(@skins) : @skins;
    my $orig = Cwd::cwd();

    for my $dir (@dirs) {
        msg("Updating checkout: $dir");
        safe_chdir($dir);

        # Try to be smart about detecting svn checkouts.
        if ( -d ".svn" ) {  
            system( "svn", "update" ) 
                and die "\"svn update\" failed!\n";
        }
        else {
            system( "svk", "update", "-s" ) 
                and die "\"svk update -s\" failed!\n";
        }
    }

    safe_chdir($orig);
}

# void link_skin(String $skin)
#
# Given the path to a valid skin, this routine creates the symlinks for that
# skin in the dev-env we're working with.
sub link_skin {
    my $skin_path = shift;
    my $skin_name = basename($skin_path);
    msg( "Linking skin: $skin_name -> " . File::Spec->abs2rel($skin_path) );

    # Make sure we're in a dev-env.  We check to see if are by looking for
    # ./share (which is lame, but works most of the time).  If we're not in a
    # dev-env, then use the one the default one.
    safe_chdir($DEFAULT_DEV_ENV) unless ok_directory("./share");

    # Link in each of the subdir types, if it exists (e.g. css, images, etc).
    # NOTE: the files in Subversion are layed out differently than they are in
    # a dev-env (or proper install), so the linking needs to take care of
    # that.  E.g. in SVN they are laid out as skin/{css,images,...} and in a
    # dev-env they are laid out as {css,images,...}/skin.
    for my $subdir (@DEFAULT_SKIN_SUBDIRS) {
        my $src  = "$skin_path/$subdir";
        my $dest = "share/$subdir/$skin_name";  # Note the inversion here.
        if ( -e $dest ) {
            msg("SKIPPING $skin_name/$subdir.  Symlink exists: $dest");
            next;
        }
        symlink( $src => $dest ) or die "Can't symlink $src => ${dest}: $!";
    }
}

#############################################################################
# Helper Routines.  Mostly business logic to support the above.

# String get_skin_path(String $base, String $skin)
#
# Return the absolute path to the skin directory for $skin, using $base as the
# base directory the skin lives in.  If the skin looks malformed throw an
# error.
sub get_skin_path {
    my ( $base, $skin ) = @_;
    my $path = abs_path("$base/$skin");
    return $path if is_valid_skin_path($path);
    die "$path does not appear to be a valid skin path!.  "
        . "Perhaps it doesn't exist or is missing an info.yaml file?\n";
}

# String get_base_skin_dir(String $dir, String $branch)
#
# Return the directory in which skins live.  If $branch is undefined then that
# directory may just be $dir, or it maybe $dir/trunk if that exists.  An error
# is thrown if a valid directory can not be found.
sub get_base_skin_dir {
    my ( $dir, $branch ) = @_;
    my @paths;

    # Deal the --branch case first, otherwise act normally.
    if ( defined $branch ) {
        $branch = "branches/$branch" unless $branch eq 'trunk';
        @paths = ("$dir/$branch/skins");
    }
    else {
        @paths = ( "$dir/trunk/skins", "$dir/skins", "$dir" );
    }

    return find_first_valid_directory(@paths);
}

# String find_first_valid_directory(List @paths)
#
# Given a list of paths return the first one that looks like a valid path.
# Otherwise die giving an error message.
sub find_first_valid_directory {

    # Look for a valid path, return the first one we find.  abs_path() is
    # better for informative error messages below.
    my @paths = map abs_path($_), @_;
    for my $path (@paths) {
        return $path if ok_directory($path);
    }

    # If we get here we didn't find a good path, error out.
    my $path_list = join( "\n   ", @paths );
    die "\nCould not find base skin directory!  "
        . "Looked in:\n\n   $path_list\n\n";
}

# Boolean is_valid_skin_path(String $path)
#
# A helper for testing a skin path for some semblance of validity.  This is
# hardly exhaustive.
sub is_valid_skin_path {
    my $path = shift;
    return ( ok_directory($path) and has_info_file($path) );
}

# Boolean has_info_file(String $path)
#
# Return true if path contains a file called info.yaml which is readable.
# False otherwise.
sub has_info_file {
    my $path = shift;
    return ( -e "$path/info.yaml" and -f _ and -r _ );
}

# List find_common_base_dirs(List @dirs)
#
# Given a list of directories return the list of unique base directories.
# E.g. if given "/foo/bar, /foo/baz, and /cow/man" this would return "/foo"
# and "/cow".  This is used to find the parent directories of a given set of
# skins, so we can do an efficient svn/svk update.
sub find_common_base_dirs {
    my @dirs = @_;
    my %bases;
    for my $dir (@dirs) {
        my $base = dirname($dir);
        $bases{$base} = 1;
    }
    return sort keys %bases;
}

#############################################################################
# Misc. Helpers.  Mostly things it'd be nice if Perl had or did right.

# Boolean ok_directory(String $path)
#
# Returns true if $path is an existing directory which we can read and chdir
# into.  False otherwise.
sub ok_directory {
    my $path = shift;
    return ( -e $path and -d $path and -r _ and -x _ );
}

# String abs_path(String $path)
#
# Like Cwd::abs_path() but if $path is illegal (or non-existant) return $path,
# rather than undef.
sub abs_path {
    my $path = shift || "";
    return Cwd::abs_path($path) || $path;
}

# void safe_chdir(String $path)
#
# chdir into $path, and die if we can't.  Regular chdir() does not die.
sub safe_chdir {
    my $dir = shift || "";
    chdir($dir) or die "Could not chdir into ${dir}: $!\n";
}

# void msg(String $msg)
#
# Prints a message out to STDOUT, immediately.  Message has a newline
# appended.
sub msg {
    my $msg = shift;
    $msg = "" unless defined $msg;
    local $| = 1;    # Autoflush STDOUT
    print "$msg\n";
}

#############################################################################
# Usage and Example Information
sub exit_with_usage {
    my $msg = shift;
    $msg = defined($msg) ? "$msg\n\n" : "";
    my $short_name = basename($0);

    print <<"USAGE";
${msg}Usage: $short_name [options] [SKIN_NAME]

    -d, --dir DIRECTORY_NAME
        The directory where the skins live.  This can either be a path to the
        top of a complete customer-skins checkout (i.e. all branches, tags,
        and trunk) or just a path to customer-skins/trunk (or some branch/tag
        of customer-skins).  Defaults to: $DEFAULT_SKIN_CHECKOUT.

    -b, --branch BRANCH_NAME
        If given then we assume that the skins directory (c.f. --dir) is a
        path to the top of a complete customer-skins checkout.  This way you
        can say "-b foobar" and get the skin you want from the foobar branch.

    -u, --update
        Assume the skins directory (c.f. --dir) is an svk or svn checkout and
        try to update it *before* creating the symlinks for the skin.
        Detection between svk/svn is done automatically.

    -a, -all
        Link all the skins found in the skins directory  (c.f. --dir).
        --branch works correctly with this command, linking all the skins from
        that branch.  This is the default behavior of the tool when called
        without any commandline arguments.

    -s, --skin SKIN_NAME
        The name of the skin to which you want to create links.  The skin can
        also be specified on the command line without a switch preceeding it,
        this option is just for convienence.

    --examples
        Prints out documentation with example use cases for this tool.
USAGE

    exit 1;
}

sub exit_with_examples {
    my $examples = join "", <DATA>;
    print $examples;
    exit 1;
}

__DATA__
EXAMPLE DOCUMENATION

=== Overview

The create-skinlinks tool works by creating symlinks to a skin within a
Socialtext developer environment.  It is assumed you have a checkout of the
customer-skins Subversion repository and that you're working within a
developer environment.

To get setup you can do the following:

    cd $HOME/src/st
    svn co https://repo.socialtext.net:8999/svn/customer-skins customer-skins
    set-branch "name-of-branch-you-are-working-on"

The "cd" command brings you to a known place on the filesystem.  Most
developers keep their files in $HOME/src/st, but you can change this part if
you keep them elsewhere.  

The "svn" command does a complete checkout of the customer-skins repository.
It gets all branches, tags, and trunk.  This is good because it allows you to
use skins which exist on branches and on trunk.  It also will make the
--branch option meaningful.

You may already have a ~/src/st/customer-skins checkout which just contains
files from the trunk of that Subversion repository.  This is fine and will
continue to work, but the --branch option will not be meaningful.  So for
your ease of use it's encouraged you have all the skins checked out, and not
just the skins on trunk.

The create-skinlinks tool, unless told otherwise using --dir, assumes your
skins live in ~/src/st/customer-skins.  If this is not where you keep skins
then you can create an alias in your shell environment setting --dir to where
you do keep your skins.

==== Example: Create a link to all the skins

    dev-bin/create-skinlinks

This links all the skins found in the skins directory.  By default that's
everything in ~/src/st/customer-skins/trunk, or ~/src/st/customer-skins/,
which ever appears to contain skins.  The --all argument to create-skinlinks
will do the same thing, but creating links for all the skins is the default
behavior.

==== Example: Create a link to all the skins in the foobar branch

    dev-bin/create-skinlinks -b foobar

This creates links to all the skins in the foobar branch.  The links will
point to ~/src/st/customer-skins/branches/foobar/$skin.  If the branches
subdir can not be found then an error is given.  Possibly you need to point to
an alternate location with --dir, or your customer-skins checkout is not a
full checkout of the repository.

==== Example: Create a link to the wired skin

    dev-bin/create-skinlinks wired

This creates links to the wired skin.  The links will point to
~/src/st/customer-skins/trunk/wired, if it exists, otherwise to
~/src/st/customer-skins/wired.  If neither of these exists then an error is
given, and you should use the --dir option to inform the tool where your
skins live.

==== Example: Create a link to the wired skin on the foobar branch

    dev-bin/create-skinlinks -b foobar wired

This creates links to the wired skin in the foobar branch.  The links
will point to ~/src/st/customer-skins/branches/foobar/wired.  If this path
doesn't exist then an error is given.  Possibly you need to point to an
alternate location with --dir, or your customer-skins checkout is not a
full checkout of the repository.

==== Example: Update your skins checkout and link to skin wired

    dev-bin/create-skinlinks -u --skin wired

Here we see that --skin can be used to specify the skin, in addition to just
supplying it unqualified on the command line.  This is for convienence and
scripting purposes.  You could just as well have left --skins off and the
command would work the same.

The -u option will run "svk update -s" or "svn update" on the customer-skins
repository before making the links.  To be specific it only runs the update
command for the specific skin you're building, so the command is run relative
to ~/src/st/customer-skins/wired or ~/src/st/customer-skins/trunk/wired, which
ever exists.  If --branch is given then that option is obeyed and still works,
and the --update command will do the right thing.

If you had not specified a skin (or had specified --all) then the update code
will try to be smart and update as few directories as possible.  i.e. it'll
try to update --dir before it tries to update each of the individual skin
directories.

==== Example: Link to a skin which lives someplace else.

Lets say you want to link to jrandom's repository.  He's been working on some
new skins and you want to use his checkout for a quick test.  Here's how you
could do that:

    dev-bin/create-skinlinks -d /home/jrandom/src/st/customer-skins foo-skin

Whether or not the --branch option will work for you depends on the
structure jrandom's checkout.  The --update option may fail because you
probably don't have write permissions to jrandom's files.  However, you can
see that with the --dir option you can load skins from anywhere.

