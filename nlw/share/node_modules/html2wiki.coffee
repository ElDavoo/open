html2wiki = (html, callback=console.log) ->
  (new HTML2Wiki).convert_html_to_wikitext(html, true, callback)
module?.exports = html2wiki
window?.html2wiki = html2wiki

###
HTML2Wiki - Converts HTML to Socialtext Wikitext syntax.

COPYRIGHT:

    Copyright (c) 2005-2011 Socialtext Corporation 
    655 High Street
    Palo Alto, CA 94301 U.S.A.
    All rights reserved.

HTML2Wiki is a derived work from the Wikiwyg javascript library.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

###

unless window?
  jsdom = require('jsdom').jsdom
  jsdom.defaultDocumentFeatures = QuerySelector: true
  window ?= jsdom().createWindow()
  document ?= window.document
  $ ?= require('jquery').create(window)
  navigator ?= userAgent: "Mozilla/5.0 AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.126 Safari/535.1"
  location ?=
    protocol: 'http'
    hostname: 'localhost'
    port: 80
  async ?= require('async')

tick = process?.nextTick || (cb) -> cb(); return

go = (cb) -> (next) -> tick ->
  cb()
  tick -> next()

unless Wikiwyg?
  Wikiwyg = ua: navigator.userAgent.toLowerCase()
  Wikiwyg.is_ie = (
    Wikiwyg.ua.indexOf("msie") != -1 &&
    Wikiwyg.ua.indexOf("opera") == -1 &&
    Wikiwyg.ua.indexOf("webtv") == -1
  )
  Wikiwyg.is_gecko = ~Wikiwyg.ua.indexOf("gecko")
  Wikiwyg.is_webkit = ~Wikiwyg.ua.indexOf("applewebkit")
  Wikiwyg.htmlUnescape = (escaped) ->
    _NewlineReplacementCharacter_ = String.fromCharCode(0xFFFC)
    return $("<div>#{
      escaped.replace(
        /</g, '&lt;'
      ).replace(
        /[ ]/g, '&#160;'
      ).replace(
        /\r?\n/g, _NewlineReplacementCharacter_
      )
    }</div>").text().replace(
      /\u00a0/g, ' '
    ).replace(
      new RegExp(_NewlineReplacementCharacter_, 'g'), "\n"
    )

LossyAttributes = [
  "fontFamily"
  "fontSize"
  "color"
  "display"
  "backgroundColor"
  "float"
]

for attr in LossyAttributes when /[A-Z]/.test(attr)
  LossyAttributes.push attr.replace(
    /([A-Z])/
    (_, $1) -> "-#{$1.toLowerCase()}"
  )

class HTML2Wiki
  constructor: ->
  proto = HTML2Wiki.prototype

  config:
    markupRules: {}

  strip_msword_gunk: (html) ->
    html.replace(
      /<SPAN\s+style="[^"]*\bmso-list:\s+Ignore\b[^"]*">[\w\W]*?<\/SPAN>/ig
      (m) -> "<!--[SocialtextBulletBegin]-->#{m}<!--[SocialtextBulletEnd]-->"
    ).replace(
      /(<P[^>]*style="[^>"]*mso-list:\s*l\d[^>"]*"[^>]* class="?)MsoNormal\b/ig
      "$1MsoListParagraphCxSpMiddle"
    ).replace(
      /(<P[^>]* class="?)MsoNormal\b([^>]*>\s*<!--\[if\s+!supportLists\]-->)/ig
      "$1MsoListParagraphCxSpMiddle$2"
    ).replace(
      /<!--\[if\s+!supportLists\]-->([\w\W]*?)<!(--)?\[endif\]-->/ig
      (m, $1) -> "<!--[SocialtextBulletBegin]-->#{$1}<!--[SocialtextBulletEnd]-->"
    ).replace(
      /<(span|\w:\w+)[^>]*>(\s*&nbsp;\s*)+<\/\1>/gi
      (m) -> if /ugly-ie-css-hack/.test(m) then m else '&nbsp;'
    ).replace(
      /<(span|\w:\w+)[^>]*><font[^>]*>(\s*&nbsp;\s*)+<\/font><\/\1>/gi
      (m) -> if /ugly-ie-css-hack/.test(m) then m else '&nbsp;'
    ).replace(
      /<!(--)?\[if\s[\w\W]*?<!(--)?\[endif\]-->/gi, ''
    ).replace(
      /<\/?(xml|st\d+:\w+|[ovwxp]:\w+)[^>]*>/gi, ''
    )

  normalizeDomStructure: (dom) ->
    @normalize_styled_blocks dom, "p"
    @normalize_styled_lists dom, "ol"
    @normalize_styled_lists dom, "ul"
    @normalize_styled_blocks dom, "li"
    @normalize_span_whitespace dom, "span"
    @normalize_empty_link_tags dom

  normalize_empty_link_tags: (dom) ->
    $("a", dom).each ->
      @parentNode.removeChild this  if @childNodes.length == 1 and @childNodes[0].nodeType == 8

  normalize_span_whitespace: (dom, tag) ->
    grep = (element) ->
      Boolean element.getAttribute("style")
    
    for element in @array_elements_by_tag_name(dom, tag, grep)
      node = element.firstChild
      while node
        if node.nodeType == 3
          node.nodeValue = node.nodeValue.replace(/^\n+/, "")
          break
        node = node.nextSibling
      node = element.lastChild
      while node
        if node.nodeType == 3
          node.nodeValue = node.nodeValue.replace(/\n+$/, "")
          break
        node = node.previousSibling

  normalize_styled_blocks: (dom, tag) ->
    for element in @array_elements_by_tag_name(dom, tag)
      style = element.getAttribute("style")
      continue  if not style or @style_is_bogus(style)
      element.removeAttribute "style"
      element.innerHTML = "<span style=\"" + style + "\">" + element.innerHTML + "</span>"

  style_is_bogus: (style) ->
    for attr in [ "line-through", "bold", "italic", "underline" ]
      return false  if @check_style_for_attribute(style, attr)
    true

  normalize_styled_lists: (dom, tag) ->
    for element in @array_elements_by_tag_name(dom, tag)
      style = element.getAttribute("style")
      continue  unless style
      element.removeAttribute "style"
      for item in $("li", element).get()
        item.innerHTML = "<span style=\"" + style + "\">" + item.innerHTML + "</span>"

  array_elements_by_tag_name: (dom, tag, grep) ->
    result = $(tag, dom).get()
    elements = []
    for element in result.length
      continue  if grep and not grep(element)
      elements.push result[i]
    elements

  normalizeDomWhitespace: (dom) ->
    for tag in [ "span", "strong", "em", "strike", "del", "tt" ]
      for element in $(tag, dom).get()
        @normalizePhraseWhitespace element
    @normalizeNewlines dom, [ "br", "blockquote" ], "nextSibling"
    @normalizeNewlines dom, [ "p", "div", "blockquote" ], "firstChild"

  normalizeNewlines: (dom, tags, relation) ->
    for tag in tags
      for node in $(tag, dom).get()
        next_node = node[relation]
        if next_node and next_node.nodeType == "3"
          next_node.nodeValue = next_node.nodeValue.replace(/^\n/, "")

  normalizePhraseWhitespace: (element) ->
    return  if @elementHasComment(element)
    if element.innerHTML == ""
      element.parentNode.removeChild element
      return
    first_node = @getFirstTextNode(element)
    prev_node = @getPreviousTextNode(element)
    last_node = @getLastTextNode(element)
    next_node = @getNextTextNode(element)
    if Wikiwyg.is_gecko and element.tagName == "SPAN"
      tmp = element.innerHTML
      element.innerHTML = tmp.replace(/<br>$/i, "")
    return  if @destroyPhraseMarkup(element)
    if first_node and /^[ ]/.test(first_node.nodeValue)
      first_node.nodeValue = first_node.nodeValue.replace(/^[ ]+/, "")
      if prev_node and not /[ ]$/.test(prev_node.nodeValue)
        prev_node.nodeValue = prev_node.nodeValue + ' '
    if last_node and /[ ]$/.test(last_node.nodeValue)
      last_node.nodeValue = last_node.nodeValue.replace(/[ ]$/, "")
      if next_node and not /^[ ]/.test(next_node.nodeValue)
        next_node.nodeValue = " " + next_node.nodeValue

  elementHasComment: (element) ->
    node = element.lastChild
    node and (node.nodeType == 8)

  end_is_no_good: (element) ->
    last_node = @getLastTextNode(element)
    next_node = @getNextTextNode(element)
    n = element
    
    while n and n.nodeType != 3
      return false  if n.nodeType == 8
      n = n.lastChild
    return true  unless last_node
    return false  if /[ ]$/.test(last_node.nodeValue)
    return false  if not next_node or next_node.nodeValue == "\n"
    not next_node.nodeValue.match(@phrase_end_re)

  phrase_end_re: /[\s\.\:\;\,\!\?\(\)\"]/

  destroyElement: (element) ->
    try
      range = element.ownerDocument.createRange()
      range.selectNode element
      docfrag = range.createContextualFragment(element.innerHTML)
      element.parentNode.replaceChild docfrag, element
      return true
    catch e
      return false

  getFirstTextNode: (element) ->
    node = element
    while node and node.nodeType != 3
      node = node.firstChild
    node

  getLastTextNode: (element) ->
    node = element
    while node and node.nodeType != 3
      node = node.lastChild
    node

  getPreviousTextNode: (element) ->
    node = element.previousSibling
    node = null  if node and node.nodeType != 3
    node

  getNextTextNode: (element) ->
    node = element.nextSibling
    node = null  if node and node.nodeType != 3
    node

  skip: ->
    ""

  pass: (element) ->
    @errors = true
    element.wikitext

  handle_undefined: proto.skip
  format_abbr: proto.pass
  format_acronym: proto.pass
  format_address: proto.pass
  format_applet: proto.skip
  format_area: proto.skip
  format_basefont: proto.skip
  format_base: proto.skip
  format_bgsound: proto.skip
  format_big: proto.pass
  format_blink: proto.pass
  format_body: proto.pass
  format_button: proto.skip
  format_caption: proto.pass
  format_center: proto.pass
  format_cite: proto.pass
  format_col: proto.pass
  format_colgroup: proto.pass
  format_dd: proto.pass
  format_dfn: proto.pass
  format_dl: proto.pass
  format_dt: proto.pass
  format_embed: proto.skip
  format_field: proto.skip
  format_fieldset: proto.skip
  format_font: proto.pass
  format_form: proto.pass
  format_frame: proto.skip
  format_frameset: proto.skip
  format_head: proto.skip
  format_html: proto.pass
  format_iframe: proto.pass
  format_input: proto.skip
  format_ins: proto.pass
  format_isindex: proto.skip
  format_label: proto.skip
  format_legend: proto.skip
  format_link: proto.skip
  format_map: proto.skip
  format_marquee: proto.skip
  format_meta: proto.skip
  format_multicol: proto.pass
  format_nobr: proto.skip
  format_noembed: proto.skip
  format_noframes: proto.skip
  format_nolayer: proto.skip
  format_noscript: proto.skip
  format_nowrap: proto.skip
  format_object: proto.skip
  format_optgroup: proto.skip
  format_option: proto.skip
  format_param: proto.skip
  format_select: proto.skip
  format_small: proto.pass
  format_spacer: proto.skip
  format_style: proto.skip
  format_script: proto.skip
  format_sub: proto.pass
  format_submit: proto.skip
  format_sup: proto.pass
  format_textarea: proto.skip
  format_tfoot: proto.pass
  format_thead: proto.pass
  format_wiki: proto.pass
  format_www: proto.skip

  check_style_for_attribute: (style, attribute) ->
    string = @squish_style_object_into_string(style)
    string.match "\\b" + attribute + "\\b"

  _for_interesting_attributes: (cb) ->
    cb "fontWeight", "font-weight"
    cb "fontStyle", "font-style"
    cb "textDecoration", "text-decoration"

  _check_lossy_attributes: (cb) ->
    return if @errors
    cb "fontFamily", "font-family"
    cb "fontSize", "font-size"
    cb "color", "display"
    cb "backgroundColor", "background-color"

  squish_style_object_into_string: (style) ->
    return  unless style
    return style  if typeof style == "string"
    string = ''

    unless @errors
      for attr in LossyAttributes when style[attr]
        @errors = true
        break

    @_for_interesting_attributes (js, css) ->
      value = style[js] || style[css]
      string += "#{css}: #{value};" if value
    string

  href_is_wiki_link: (href) ->
    return true  unless @looks_like_a_url(href)
    href = location.href  if ~href.indexOf("/static/") and ~href.indexOf("/skin/js-test/")
    up_to_wksp = /^https?:\/\/([^:\/]+)[^\/]*\/(?!(?:nlw|challenge|data|feed|js|m|settings|soap|st|wsdl)\/)[^\/#]+\//
    no_page_input = href.match(up_to_wksp)
    return false  unless no_page_input
    return false  unless no_page_input[1].toLowerCase() == location.hostname.toLowerCase()
    query = href.split("?")[1]
    return true  unless query
    (not /[=]/.test(query)) or /action=display\b/.test(query)

  looks_like_a_url: (string) ->
    /^(http|https|ftp|irc|mailto|file):/.test(string)

  destroyPhraseMarkup: (element) ->
    return false  if @contain_widget_image(element)
    return @destroyElement(element)  if @start_is_no_good(element) or @end_is_no_good(element)
    false

  contain_widget_image: (element) ->
    for e in element.childNodes
      if e.nodeType == 1 and e.nodeName == "IMG"
        if /^st-widget-/.test(e.getAttribute("alt"))
          return true
    false

  markupRules:
    italic: [ "bound_phrase", "_", "_" ]
    underline: [ "bound_phrase", "", "" ]
    h1: [ "start_line", "^ " ]
    h2: [ "start_line", "^^ " ]
    h3: [ "start_line", "^^^ " ]
    h4: [ "start_line", "^^^^ " ]
    h5: [ "start_line", "^^^^^ " ]
    h6: [ "start_line", "^^^^^^ " ]
    www: [ "bound_phrase", "\"", "\"<http://...>" ]
    attach: [ "bound_phrase", "{file: ", "}" ]
    image: [ "bound_phrase", "{image: ", "}" ]
    video: [ "bound_phrase", "{video: ", "}" ]
    widget: [ "bound_phrase", "{widget: ", "}" ]
    link: ['bound_phrase', '[', ']'],
    bold: ['bound_phrase', '*', '*'],
    code: ['bound_phrase', '`', '`'],
    strike: ['bound_phrase', '-', '-'],
    p: ['start_lines', ''],
    pre: ['start_lines', '    '],
    ordered: ['start_lines', '#'],
    unordered: ['start_lines', '*'],
    indent: ['start_lines', '>'],
    hr: ['line_alone', '----'],

  canonicalText: ->
    wikitext = @getTextArea()
    wikitext += "\n"  unless wikitext[wikitext.length - 1] == "\n"
    @convert_tsv_sections wikitext

  convert_tsv_sections: (text) ->
    text.replace(
      /^tsv:\s*\n((.*(?:\t|[ ]{2,}).*\n)+)/gim,
      (s) => @detab_table s
    )

  detab_table: (text) ->
    text.replace(/\r/g, '')
        .replace(/^tsv:\s*\n/, '')
        .replace(/(\t|[ ]{2,})/g, '|')
        .replace(/^/gm, '|')
        .replace(/\n/g, '|\n')
        .replace(/\|$/, '')

  href_label_similar: (elem, href, label) ->
    id_from_href = nlw_name_to_id(href)
    id_from_label = nlw_name_to_id(label)
    id_from_attr = nlw_name_to_id($(elem).attr("wiki_page") or "")
    (id_from_href == id_from_label) or id_from_attr == id_from_label

  start_is_no_good: (element) ->
    first_node = @getFirstTextNode(element)
    prev_node = @getPreviousTextNode(element)
    return true  unless first_node
    return false  if /^[ ]/.test(first_node.nodeValue)
    return false  unless prev_node
    return false  if /^\n?[\u00a0\ ]?/.test(prev_node.nodeValue)
    return false  if prev_node.nodeValue == "\n"
    not /[\(\ "]$/.test(prev_node.nodeValue)

  _is_block_level_node: (node) ->
    node and node.nodeName and
    /^(?:UL|LI|OL|P|H\d+|HR|TABLE|TD|TR|TH|THEAD|TBODY|BLOCKQUOTE)$/.test(node.nodeName)

  build_msoffice_list: (top) ->
    $top = $(top)
    firstHtml = $top.html()
    return  unless /<!--\[SocialtextBulletBegin\]-->[\w\W]*?<!--\[SocialtextBulletEnd\]-->/.test(firstHtml)
    firstHtml = firstHtml.replace(
      /<!--\[SocialtextBulletBegin\]-->(?:<\w[^>]*>)*([\w\W]*?)<!--\[SocialtextBulletEnd\]-->/, ''
    )
    bulletText = RegExp.$1
    listType = (if /^\w+\./.test(bulletText) then "ol" else "ul")
    cur = top
    newHtml = "<li>" + firstHtml + "</li>"
    toRemove = []
    while cur = $(cur).next(
      "p.ListParagraphCxSpMiddle, p.ListParagraphCxSpLast," +
      "p.MsoListParagraphCxSpMiddle, p.MsoListParagraphCxSpLast"
    )[0]
      $cur = $(cur)
      continue  if $cur.hasClass("_st_walked")
      if parseInt($cur.css("text-indent") or "0") == 0 and ($cur.text().search(/\S/) == -1)
        toRemove.push $cur
        continue
      topIndent = @_css_to_px($top.css("margin-left")) or 0
      curIndent = @_css_to_px($cur.css("margin-left")) or 0
      if curIndent < topIndent
        break
      else if curIndent > topIndent
        newHtml += @build_msoffice_list(cur)
      else
        newHtml += '<li>' + $cur.html().replace(
          /<!--\[SocialtextBulletBegin\]-->[\w\W]*?<!--\[SocialtextBulletEnd\]-->/, ''
        ) + '</li>'
      $cur.addClass "_st_walked"
      toRemove.push $cur
    $_.remove() for $_ in toRemove
    "<#{listType}>#{newHtml}</#{listType}>"

  doFixVisualBR: (dom, next) ->
    loop
      paragraphs = $("p", dom).get()
      len = paragraphs.length
      break  unless len
      foundVisualBR = false
      for cur in paragraphs
        continue  if ~cur.className.indexOf("st_walked")
        if @_css_to_px(cur.style.marginBottom) < 1
          nextNode = @_get_next_node(cur)
          if nextNode and nextNode.nodeType == 1 and nextNode.nodeName == "P"
            cur.style.marginBottom = nextNode.style.marginBottom
            $nextNode = $(nextNode)
            $(cur).append "<br />" + $nextNode.html()
            $nextNode.remove()
            foundVisualBR = true
            break
        cur.className += (if cur.className then " " else "") + "st_walked"
      break unless foundVisualBR
    next()

  convert_html_to_wikitext: (html, isWholeDocument, callback) ->
    self = this
    @errors = null
    return callback(@errors, "") unless html? and html != ""
    dom = document.createElement("div")
    $dom = null
    async.series [
      go =>
        html = html.toString().replace(/^\s*<div(?:\s*\/|><\/div)>/, "")
        html = @strip_msword_gunk(html)
      (next) =>
        dom.innerHTML = html
        cur = null
        async.whilst(
          => cur = $(dom).find("p.ListParagraphCxSpFirst:first, p.MsoListParagraphCxSpFirst:first, p.MsoListParagraph:first, p.ListParagraph:first")[0]
          go => $(cur).replaceWith @build_msoffice_list(cur)
          =>
            $(dom).find("._st_walked").removeClass "_st_walked"
            next()
        )
      (next) => @doFixVisualBR dom, next
      go =>
        $(dom).find("td, hr, pre").parents("span:not(.nlw_phrase), a, h1, h2, h3, h4, h5, h6, b, strong, i, em, strike, del, s, tt, code, kbd, samp, var, u").addClass "_st_format_div"
        $(dom).find("._st_walked").removeClass "_st_walked"
        if Wikiwyg.is_ie
          for elem in $("div", dom).get()
            continue  unless elem.className == "wiki"
            div = document.createElement("div")
            div.innerHTML = elem.innerHTML
            elem.parentNode.replaceChild div, elem
          html = dom.innerHTML
          return
        # Not IE...
        $dom = $(dom)
        $dom.find("div.wiki").each ->
          html = $(@).html()
          if /<br\b[^>]*>\s*$/i.test(html)
            $(@).replaceWith html
          else
            $(@).replaceWith html + "<br />"
        cleanup_newlines = ->
          if @nodeType == 3
            if @previousSibling and @previousSibling.nodeType == 1 and @previousSibling.nodeName != "BR"
              if self._is_block_level_node(@previousSibling)
                @nodeValue = @nodeValue.replace(/^\n/, "")
              else
                @nodeValue = @nodeValue.replace(/^\n/, " ")
            else
              @nodeValue = @nodeValue.replace(/^\n/, "")
            if @nextSibling and @nextSibling.nodeType == 1 and @nextSibling.nodeName != "BR"
              if self._is_block_level_node(@nextSibling)
                @nodeValue = @nodeValue.replace(/\n$/, "")
              else
                @nodeValue = @nodeValue.replace(/\n$/, " ")
            else
              @nodeValue = @nodeValue.replace(/\n$/, "")
            @nodeValue = @nodeValue.replace(/\n/g, " ")
          else $(this).contents().not("iframe").each cleanup_newlines  if $(this).is(":not(pre,plain)")
        
        if isWholeDocument
          contents = $dom.find("div.wiki").contents()
          if contents.length == 0
            $dom.find("iframe").remove()
            contents = $dom.contents()
          if contents?.length > 0
            for firstNode in contents.get()
              continue  if firstNode.nodeType == 1 and firstNode.innerHTML == ""
              if firstNode.nodeType == 3
                firstNode.nodeValue = firstNode.nodeValue.replace(/^\n/, "")
              break

            for lastNode in contents.get().reverse()
              continue  if lastNode.nodeType == 1 and lastNode.innerHTML == ""
              if lastNode.nodeType == 3
                lastNode.nodeValue = lastNode.nodeValue.replace(/\n$/, "")
              break
            contents.each cleanup_newlines
        else
          $dom.contents().each cleanup_newlines
        html = $dom.html()
      go =>
        @copyhtml = html
        dom = document.createElement("div")
        dom.innerHTML = html
        @output = []
        @list_type = []
        @indent_level = 0
        @no_collapse_text = false
        @depth = 0
        @normalizeDomWhitespace dom
        @normalizeDomStructure dom
        @dom = dom
      go => @walk dom, (wikitext) =>
        callback @errors, wikitext.replace(/[\u00a0\s\n]*$/, "\n").replace(/\r/g, "")
    ]

  walk: (elem, callback) ->
    @depth++
    return callback("") unless elem

    part = elem.firstChild
    async.whilst(
      -> part
      (next) =>
        if part.nodeType == 1 and not @no_descend(part)
          @walk part, (wikitext) ->
            part.wikitext = wikitext
            part = part.nextSibling
            tick -> next()
        else
          part = part.nextSibling
          tick -> next()
        return
      =>
        @wikitext = ""
        fixups = []
        part = elem.firstChild
        async.whilst(
          -> part
          (next) =>
            if part.nodeType == 3
              if not (part.nodeValue.match(/[^\n]/) and (not part.nodeValue.match(/^\n[\n\ \t]*$/))) or (part.nodeValue.match(/^\s+$/) and part.previousSibling and part.previousSibling.nodeName == "BR" and part.previousSibling.previousSibling and part.previousSibling.previousSibling.nodeName == "BR")
                node = part
                part = part.nextSibling
                node.parentNode.removeChild node
                return next()
            method = "format_" + part.nodeName.toLowerCase()
            method = "format_indent"  if method != "format_blockquote" and part.is_indented
            method = "format_div"  if /\b_st_format_div\b/.test(part.className)
            method = method.replace(/#/, "")
            try
              text = @[method](part)
              if part.fixup
                text = "\u0007" + text + "\u0007"
                fixups.push [ part.fixup, part ]
              unless text
                part = part.nextSibling
                return next()
              if @wikitext and @wikitext != "\n"
                node = part
                
                while node
                  if node.top_level_block
                    len = @wikitext.length
                    len--  if @wikitext.charAt(len - 1) == "\n"
                    len--  if @wikitext.charAt(len - 1) == "\n"
                    while @wikitext.charAt(len - 1) == " "
                      len--
                    if len == @wikitext.length
                      @wikitext += "\n\n"
                    else
                      @wikitext = @wikitext.substr(0, len) + "\n\n"
                    break
                  break  if @_is_block_level_node(node)
                  node = node.firstChild
              @assert_trailing_space part, text
              @wikitext += text
            part = part.nextSibling
            next()
          =>
            @[fixup[0]](fixup[1]) for fixup in fixups
            @depth--
            return callback("") unless (@wikitext.length and @wikitext.match(/\S/))
            callback(@wikitext)
        )
    )

  assert_trailing_space: (part, text) ->
    return  if (not part.requires_preceding_space) and (not part.previousSibling) or (not part.previousSibling.requires_trailing_space) or (part.nodeName == "BR")
    return  if /[ ]$/.test(@wikitext)
    if /\n$/.test(@wikitext)
      return  if part.previousSibling and (part.previousSibling.nodeName == "BR" or part.previousSibling.nodeName == "HR")
      return  if part.top_level_block
      @wikitext = @wikitext.replace(/\n$/, "")
    return  if /^\s/.test(text)
    if part.top_level_block
      @wikitext += "\n"
    else
      @wikitext += " "

  _css_to_px: (val = "") ->
    if val.match(/^-?([\.\d]+)px/)
      return Number(RegExp.$1)
    else if val.match(/^-?([\.\d]+)in/)
      return Number(RegExp.$1) * 80
    else if val.match(/^-?([\.\d]+)cm/)
      return Number(RegExp.$1) * 28
    else if val.match(/^-?([\.\d]+)em/)
      return Number(RegExp.$1) * 10
    else if val.match(/^-?([\.\d]+)ex/)
      return Number(RegExp.$1) * 6
    else return Number(RegExp.$1) * 4 / 3  if val.match(/^-?([\.\d]+)pt/)
    undefined

  no_descend: (elem) ->
    if elem.nodeName == "BLOCKQUOTE"
      elem.is_indented = true
    else if elem.nodeName.match(/^(P|DIV)$/)
      indent = @_css_to_px(elem.style.marginLeft)
      elem.is_indented = indent  unless indent == undefined
    Boolean (elem.nodeName.match(/^(DIV|SPAN)$/) and elem.className.match(/^(nlw_phrase|wafl_block)$/)) or (elem.nodeName == "A" and elem.lastChild and elem.lastChild.nodeType == 8) or (elem.nodeName == "A") or (elem.nodeName == "SPAN") and @get_wiki_comment(elem)

  check_start_of_block: (elem) ->
    prev = elem.previousSibling
    next = elem.nextSibling
    @wikitext += "\n"  if @wikitext and prev and prev.top_level_block and not /\n\n$/.test(@wikitext) and not (elem.nodeType == 3) and (not /\S/.test(elem.nodeValue)) and (next and next.nodeName == "BR") and (/\n$/.test(@wikitext) or next.nextSibling and next.nextSibling.nodeName == "BR")

  _get_next_node: (elem) ->
    return elem  unless elem
    if elem.nextSibling
      return @_get_next_node(elem.nextSibling)  if elem.nextSibling.nodeType == 3 and elem.nextSibling.nodeValue.match(/^[\u00a0\s]*$/)
      return elem.nextSibling
    @_get_next_node elem.parentNode

  format_text: (elem) ->
    elem.top_level_block = true  if elem.previousSibling and elem.previousSibling.nodeName == "P" and elem.previousSibling.wikitext == ""
    @check_start_of_block elem
    text = elem.nodeValue.replace(/^\n+/, "").replace(/[\u00a0\ ]+/g, " ")
    if text.match(/^[\u00a0\s]+$/)
      next = @_get_next_node(elem)
      return ""  unless next
      return ""  if next.nodeType == 1 and (next.nodeName == "BR" or @_is_block_level_node(next))
    text = text.replace(/^\s+/, "")  if text.match(/^\s+/) and elem.previousSibling and elem.previousSibling.nodeType == 1 and elem.previousSibling.nodeName == "BR"
    text = text.replace(/\s+$/, "")  if text.match(/\s+$/) and elem.nextSibling and elem.nextSibling.nodeType == 1 and elem.nextSibling.nodeName == "BR"
    text = text.replace(/\u00a0[ ]/g, " ")
    text = text.replace(/\u00a0/g, " ")
    text

  format_div: (elem) ->
    if elem.className == "nlw_phrase"
      elem.top_level_block = true
      return @handle_nlw_phrase(elem)
    return @handle_wafl_block(elem)  if elem.className == "wafl_block"
    text = elem.wikitext
    text.replace(/^\s+$/, "").replace(/\n*$/, "\n")

  handle_nlw_phrase: (elem) ->
    @check_start_of_block elem
    comment = elem.lastChild
    text = Wikiwyg.htmlUnescape(comment.nodeValue)
                  .replace(/^[ ]wiki:[ ]([\s\S]*?)[ ]?$/, '$1')
                  .replace(/\n*$/, '')
                  .replace(/[-][=]/g, '-')
                  .replace(/[=][=]/g, '=')
    elem.is_widget = true
    prev = elem.previousSibling
    elem.widget_on_widget = true  if prev and prev.nodeName == "BR" and prev.previousSibling and prev.previousSibling.is_widget
    @handle_include text, elem

  handle_wafl_block: (elem) ->
    comment = elem.lastChild
    return  unless comment
    text = comment.data
    text = text.replace(
      /^[ ]wiki:\s+/, ""
    ).replace(/[-][=]/g, "-").replace(/[=][=]/g, "=")
    elem.top_level_block = true
    text

  format_p: (elem) ->
    if elem.className == "padding" and not @wikitext
      return "\n"  if Wikiwyg.is_ie
      return
    text = elem.wikitext
    elem.top_level_block = true
    unless text
      return "\n"  if Wikiwyg.is_ie and elem == elem.parentNode.lastChild
      return
    return  if text == " "
    text + "\n"

  format_img: (elem) ->
    widget = elem.getAttribute("alt")
    if /^st-widget-/.test(widget)
      widget = widget.replace(/^st-widget-/, "")
      widget = Wikiwyg.htmlUnescape(widget)  if Wikiwyg.is_ie
      if $.browser.webkit
        widget = widget.replace(
          /&#x([a-fA-F\d]{2,5});/g
          ($_, $1) -> String.fromCharCode parseInt($1, 16)
        )
      if /^\.[-\w]+\n/.test(widget)
        elem.top_level_block = true
      else
        elem.is_widget = true
      @check_start_of_block elem
      text = widget.replace(/[-][=]/g, "-").replace(/[=][=]/g, "=")
      prev = elem.previousSibling
      requires_preceding_space = false
      unless /\{\{.*\}\}/.test(text)
        elem.requires_trailing_space = true  unless elem.top_level_block
        if prev and not (prev.nodeType == 1 and prev.nodeName == "BR") and not prev.top_level_block
          if prev.nodeType == 3 and Wikiwyg.is_ie
            elem.requires_preceding_space = true
          else
            prev.requires_trailing_space = true
      text = @handle_include(text, elem)
      text = text.replace(/\n*$/, "\n")  if widget.match(/^\.[-\w]+\n/)
      elem.requires_trailing_space = true  unless text.match(/\{\{\{.*\}\}/)  if Wikiwyg.is_ie
      elem.widget_on_widget = true  if prev and prev.nodeName == "BR" and prev.previousSibling and prev.previousSibling.is_widget
      return text
    uri = elem.getAttribute("src")
    if uri
      @check_start_of_block elem
      uri

  handle_include: (text, elem) ->
    if text.match(/^{include:/)
      if not @wikitext or @wikitext.match(/\n$/)
        next = elem.nextSibling
        if next
          next.nodeValue = next.nodeValue.replace(/^\s*/, "")  if next.nodeType == 3 and next.nodeValue.match(/\S/)
          next.wikitext = next.wikitext.replace(/^\s*/, "")  if next.nodeType == 1
      @is_include = true
      elem.requires_trailing_space = null
    text

  _format_one_line: (elem) ->
    style = @squish_style_object_into_string(elem.style)
    if not style or style == ""
      if (elem.parentNode.nodeName == "P") and (elem.parentNode.className == "MsoNormal")
        
      else
        return elem.wikitext
    elem.wikitext = elem.wikitext.replace(/\n/g, " ").replace(/[ ]+/, ' ')
    elem.wikitext = @format_b(elem)  if style.match(/font-weight: bold;/)
    elem.wikitext = @format_i(elem)  if style.match(/font-style: italic;/)
    elem.wikitext = @format_strike(elem)  if style.match(/text-decoration: line-through;/)
    elem.wikitext

  format_span: (elem) ->
    return @handle_nlw_phrase(elem)  if (elem.className == "nlw_phrase") or @get_wiki_comment(elem)
    @_format_one_line elem

  format_indent: (elem) ->
    px = elem.is_indented
    while px > 0
      elem.wikitext = @format_blockquote(elem)
      px -= 40
    elem.wikitext

  format_blockquote: (elem) ->
    unless (elem.parentNode.is_indented or (elem.previousSibling and elem.previousSibling.is_indented))
      elem.top_level_block = true
    else
      @wikitext = @wikitext.replace(/[ ]$/, "")
      @wikitext += "\n"  if @wikitext and not /\n$/.test(@wikitext)
    elem.wikitext
        .replace(/^[>]/mg, ">>")
        .replace(/^([^>])/mg, "> $1")
        .replace(/[ ]*$/mg, "")
        .replace(/\n*$/, "\n")

  format_li: (elem) ->
    "\u0007#{
        elem.wikitext
            .replace(/^\u00a0$/, '')
            .replace(/^\s*/, '')
            .replace(/\n+/g, '\n')
            .replace(/[ ][ ]+/, ' ')
            .replace(/[\n ]*$/, '')
    }\n"

  format_ul: (elem) ->
    elem.top_level_block = true  unless /^(UL|OL)$/.test(elem.parentNode.nodeName)
    elem.wikitext
        .replace(/^([*]+)([ ]|$)/mg, '*$1$2')
        .replace(/^([#]+)([ ]|$)/mg, '#$1$2')
        .replace(/^\u0007$/mg, '*')
        .replace(/^\u0007(?=.)/mg, '* ')

  format_ol: (elem) ->
    elem.top_level_block = true  unless /^(UL|OL)$/.test(elem.parentNode.nodeName)
    elem.wikitext
        .replace(/^([*]+)([ ]|$)/mg, '*$1$2')
        .replace(/^([#]+)([ ]|$)/mg, '#$1$2')
        .replace(/^\u0007$/mg, '#')
        .replace(/^\u0007(?=.)/mg, '# ')

  format_table: (elem) ->
    elem.top_level_block = true
    options = $(elem).attr("options")
    (if options then "|| " + options + "\n" else "") + elem.wikitext

  format_tr: (elem) ->
    elem.wikitext + "|\n"

  format_td: (elem) ->
    if elem.firstChild and /^(H[123456])$/.test(elem.firstChild.nodeName)
      elem.wikitext = elem.wikitext.replace(/\n?$/, "\n")  unless elem.wikitext == ""
      return "| " + elem.wikitext
    if elem.firstChild and /^(OL|UL|BLOCKQUOTE)$/.test(elem.firstChild.nodeName)
      elem.wikitext = "\n" + elem.wikitext.replace(/\n$/, " ")
      return "| " + elem.wikitext
    if /\n/.test(elem.wikitext) or (elem.firstChild and elem.firstChild.top_level_block)
      elem.wikitext = elem.wikitext.replace(/\s?\n?$/, " ")
      return "| " + elem.wikitext
    else
      style = @squish_style_object_into_string(elem.getAttribute("style"))
      elem.wikitext = @format_b(elem)  if style and style.match(/font-weight: bold;/)
      elem.wikitext = @format_i(elem)  if style and style.match(/font-style: italic;/)
      elem.wikitext = @format_strike(elem)  if style and style.match(/text-decoration: line-through;/)
    "| " + elem.wikitext + " "

  format_th: proto.format_td
  format_tbody: (elem) ->
    elem.wikitext

  for i in [1..6]
    padding = ""
    padding += "^" for [1..i]
    padding += " "
    ((p) ->
      proto["format_h" + i] = (elem) ->
        elem.top_level_block = true
        text = @_format_one_line(elem)
        return ""  if text == ""
        text = p + text
        text.replace /\n*$/, "\n"
    ) padding
  format_pre: (elem) ->
    data = Wikiwyg.htmlUnescape(elem.innerHTML)
    data = data.replace(/<br>/g, "\n").replace(/\r?\n$/, "").replace(/^&nbsp;$/, "\n")
    elem.top_level_block = true
    ".pre\n" + data + "\n.pre\n"

  format_a: (elem) ->
    if elem.innerHTML == ""
      name = elem.getAttribute("name")
      return "" unless name
      return "{section: #{name}}"
    if elem.childNodes.length == 1 and elem.childNodes[0].nodeType == 1
      additional_styles = elem.childNodes[0].getAttribute("style")
      if additional_styles
        if (additional_styles.constructor + "").match("String")
          elem.setAttribute "style", elem.getAttribute("style") + ";" + additional_styles
        else
          @_for_interesting_attributes (js) ->
            elem.style[js] = additional_styles[js]  if additional_styles[js]
    @check_start_of_block elem
    label = elem.innerHTML
    label = label.replace(/<[^>]*>/g, " ")
    label = Wikiwyg.htmlUnescape(label)
    label = label.replace(/\s+/g, " ").replace(/^\s+/, "").replace(/\s+$/, "")
    href = elem.getAttribute("href")
    href = href.replace(/^(?:\.\.\/)+/, location.protocol + "//" + location.hostname + (if (location.port == 80) or (location.port == "") then "" else ":" + location.port) + "/")
    href = ""  unless href
    link = @make_wikitext_link(label, href, elem)
    if /^[\[{]/.test(link)
      prev_node = @getPreviousTextNode(elem)
      link = " " + link  if prev_node and prev_node.nodeValue.match(/\w$/)
      next_node = @getNextTextNode(elem)
      link = link + " "  if next_node and next_node.nodeValue.match(/^\w/)
    elem.fixup = "strip_ears"
    elem.wikitext = link
    @_format_one_line elem

  strip_ears: (elem) ->
    @wikitext = @wikitext.replace(/(^|[\s\S])\x07([^\x07]*)\x07([\s\S]|$)/, ($0, $1, $2, $3) =>
      link = $2
      return $1 + link + $3  if link.match(/\s/)
      return $1 + link  if @is_italic(elem.parentNode)  if @wikitext.match(/>\x07$/)
      link = link.replace(/^<(.*)>$/, "$1")  if (not ($1.match(/\S/) or $3.match(/\S/))) or ($1 == "'" and not $3.match(/\S/))
      $1 + link + $3
    )

  is_italic: (elem) ->
    elem and (elem.nodeName == "I" or elem.nodeName == "EM" or (elem.nodeName == "SPAN" and ((elem) =>
      style = ""
      try
        style = @squish_style_object_into_string(elem.getAttribute("style"))
      /font-style: italic;/.test style
    )(elem)))

  elem_is_wiki_link: (elem, href) ->
    href = href or elem.getAttribute("href") or ""
    $(elem).attr("wiki_page") or @href_is_wiki_link(href)

  make_wikitext_link: (label, href, elem) ->
    mailto = href.match(/^mailto:(.*)/)
    if @elem_is_wiki_link(elem, href)
      @handle_wiki_link label, href, elem
    else if mailto
      address = mailto[1]
      address = address.replace(/\%25/g, "%")  if Wikiwyg.is_ie and $.browser.version == 6
      if address == label
        address
      else
        "\"" + label + "\"<" + href + ">"
    else
      if href == label
        "<" + href + ">"
      else if @looks_like_a_url(label)
        "<" + label + ">"
      else
        "\"" + label + "\"<" + href + ">"

  handle_wiki_link: (label, href, elem) ->
    up_to_wksp = /^https?:\/\/[^\/]+\/([^\/#]+)\/(?:(?:index.cgi)?\?)?/
    match = href.match(up_to_wksp)
    wksp = (if match then match[1] else Socialtext.wiki_id)
    href_orig = href
    is_incipient = false
    if /.*\baction=display;is_incipient=1;page_name=/.test(href)
      is_incipient = true
      href = href.replace(/.*\baction=display;is_incipient=1;page_name=/, "")
    href = href.replace(up_to_wksp, "")
    href = decodeURIComponent(href)
    href = href.replace(/_/g, " ")
    wiki_page = $(elem).attr("wiki_page")
    prefix = ""
    page = ""
    if label == href_orig and (label.indexOf("=") == -1)
      page = wiki_page or href
    else if @href_label_similar(elem, href, label)
      page = wiki_page or label
    else
      page = wiki_page or href
      prefix = "\"" + label + "\""
    if /#/.test(page) and (page == href) and not is_incipient
      segments = page.split(/#/, 2)
      section = segments[1]
      page = segments[0]
      prefix + "{link: " + wksp + " [" + page + "] " + section + "}"
    else unless wksp == Socialtext.wiki_id
      prefix + "{link: " + wksp + " [" + page + "]}"
    else
      prefix + "[" + page + "]"

  COMMENT_NODE_TYPE: 8
  get_wiki_comment: (elem) ->
    node = elem.firstChild
    
    while node
      return node  if node.nodeType == @COMMENT_NODE_TYPE and node.data.match(/^\s*wiki/)
      node = node.nextSibling
    null

  format_br: (elem) ->
    return @format_hr(elem)  if elem.style.pageBreakBefore == "always"
    @wikitext = @wikitext.replace(/\u00a0/, "")  if Wikiwyg.is_ie
    "\n"

  format_hr: (elem) ->
    return ""  if @has_parent(elem, "LI")
    "----\n"

  has_parent: (elem, name) ->
    while elem = elem.parentNode
      return true  if elem.nodeName == name
    false

  style_of =
    b: "bold"
    strong: "bold"
    i: "italic"
    em: "italic"
    strike: "strike"
    del: "strike"
    s: "strike"
    tt: "code"
    code: "code"
    kbd: "code"
    samp: "code"
    var: "code"
    u: "underline"

  build_bound_phrase_formatter = (style) ->
    (elem) ->
      @check_start_of_block elem
      markup = @config.markupRules[style]
      markup_open = markup[1]
      markup_close = markup[2] or markup_open
      @errors = true unless markup_close # underline is lossy
      wikitext = elem.wikitext
      prev_node = elem.previousSibling
      if prev_node and prev_node.nodeType == 3
        if prev_node.nodeValue.match(/\w$/) and wikitext.match(/^\S/)
          return wikitext
        else wikitext = wikitext.replace(/^\s+/, "")  if prev_node.nodeValue.match(/\s$/)
      next_node = elem.nextSibling
      if next_node and next_node.nodeType == 3
        if next_node.nodeValue.match(/^\w/) and wikitext.match(/\S$/)
          return wikitext
        else wikitext = wikitext.replace(/\s+$/, "")  if next_node.nodeValue.match(/^\s/)
      return wikitext  unless (/\S/.test(wikitext))
      wikitext.replace(/^(\s*)/, "$1" + markup_open).replace(/(\s*)$/, markup_close + "$1").replace /\n/g, " "

  for tag, style of style_of
    proto["format_" + tag] = build_bound_phrase_formatter(style)

  proto.config.markupRules[k] = v for k, v of proto.markupRules

