html2wiki = (html) -> (new HTML2Wiki).convert_html_to_wikitext html, true
module?.exports = html2wiki
window?.html2wiki = html2wiki

###
HTML2Wiki - Converts HTML to Socialtext Wikitext syntax.

COPYRIGHT:

    Copyright (c) 2005-2011 Socialtext Corporation 
    655 High Street
    Palo Alto, CA 94301 U.S.A.
    All rights reserved.

HTML2Wiki is a derived work from the Wikiwyg javascript library.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

###

unless window?
  jsdom = require('jsdom').jsdom
  jsdom.defaultDocumentFeatures = QuerySelector: true
  window ?= jsdom().createWindow()
  document ?= window.document
  $ ?= require('jquery').create(window)
  navigator ?= userAgent: "Mozilla/5.0 AppleWebKit/535.1 (KHTML, like Gecko) Chrome/14.0.835.126 Safari/535.1"

unless Wikiwyg?
  Wikiwyg = ua: navigator.userAgent.toLowerCase()
  Wikiwyg.is_ie = (
    Wikiwyg.ua.indexOf("msie") != -1 &&
    Wikiwyg.ua.indexOf("opera") == -1 &&
    Wikiwyg.ua.indexOf("webtv") == -1
  )
  Wikiwyg.is_gecko = ~Wikiwyg.ua.indexOf("gecko")
  Wikiwyg.is_webkit = ~Wikiwyg.ua.indexOf("applewebkit")
  Wikiwyg.htmlUnescape = (escaped) ->
    _NewlineReplacementCharacter_ = String.fromCharCode(0xFFFC)
    return $("<div>#{
      escaped.replace(
        /</g, '&lt;'
      ).replace(
        /[ ]/g, '&#160;'
      ).replace(
        /\r?\n/g, _NewlineReplacementCharacter_
      )
    }</div>").text().replace(
      /\xA0/g, ' '
    ).replace(
      new RegExp(_NewlineReplacementCharacter_, 'g'), "\n"
    )

class HTML2Wiki
  constructor: ->

HTML2Wiki.prototype = proto = config: markupRules: {}

proto.strip_msword_gunk = (html) ->
  html.replace(/<SPAN\s+style="[^"]*\bmso-list:\s+Ignore\b[^"]*">[\w\W]*?<\/SPAN>/g, (m) ->
    "<!--[SocialtextBulletBegin]-->" + m + "<!--[SocialtextBulletEnd]-->"
  ).replace(/(<P[^>]*style="[^>"]*mso-list:\s*l\d[^>"]*"[^>]* class="?)MsoNormal\b/g, "$1MsoListParagraphCxSpMiddle").replace(/(<P[^>]* class="?)MsoNormal\b([^>]*>\s*<!--\[if\s+!supportLists\]-->)/g, "$1MsoListParagraphCxSpMiddle$2").replace(/<!--\[if\s+!supportLists\]-->([\w\W]*?)<!(--)?\[endif\]-->/g, (m, $1) ->
    "<!--[SocialtextBulletBegin]-->" + $1 + "<!--[SocialtextBulletEnd]-->"
  ).replace(/<(span|\w:\w+)[^>]*>(\s*&nbsp;\s*)+<\/\1>/g, (m) ->
    (if m.match(/ugly-ie-css-hack/) then m else "&nbsp;")
  ).replace(/<(span|\w:\w+)[^>]*><font[^>]*>(\s*&nbsp;\s*)+<\/font><\/\1>/g, (m) ->
    (if m.match(/ugly-ie-css-hack/) then m else "&nbsp;")
  ).replace(/<!(--)?\[if\s[\w\W]*?<!(--)?\[endif\]-->/g, "").replace /<\/?(xml|st\d+:\w+|[ovwxp]:\w+)[^>]*>/g, ""

proto.normalizeDomStructure = (dom) ->
  @normalize_styled_blocks dom, "p"
  @normalize_styled_lists dom, "ol"
  @normalize_styled_lists dom, "ul"
  @normalize_styled_blocks dom, "li"
  @normalize_span_whitespace dom, "span"
  @normalize_empty_link_tags dom

proto.normalize_empty_link_tags = (dom) ->
  $("a", dom).each ->
    @parentNode.removeChild this  if @childNodes.length == 1 and @childNodes[0].nodeType == 8

proto.normalize_span_whitespace = (dom, tag) ->
  grep = (element) ->
    Boolean element.getAttribute("style")
  
  for element in @array_elements_by_tag_name(dom, tag, grep)
    node = element.firstChild
    while node
      if node.nodeType == 3
        node.nodeValue = node.nodeValue.replace(/^\n+/, "")
        break
      node = node.nextSibling
    node = element.lastChild
    while node
      if node.nodeType == 3
        node.nodeValue = node.nodeValue.replace(/\n+$/, "")
        break
      node = node.previousSibling

proto.normalize_styled_blocks = (dom, tag) ->
  for element in @array_elements_by_tag_name(dom, tag)
    style = element.getAttribute("style")
    continue  if not style or @style_is_bogus(style)
    element.removeAttribute "style"
    element.innerHTML = "<span style=\"" + style + "\">" + element.innerHTML + "</span>"

proto.style_is_bogus = (style) ->
  for attr in [ "line-through", "bold", "italic", "underline" ]
    return false  if @check_style_for_attribute(style, attr)
  true

proto.normalize_styled_lists = (dom, tag) ->
  for element in @array_elements_by_tag_name(dom, tag)
    style = element.getAttribute("style")
    continue  unless style
    element.removeAttribute "style"
    for item in element.getElementsByTagName("li")
      item.innerHTML = "<span style=\"" + style + "\">" + item.innerHTML + "</span>"

proto.array_elements_by_tag_name = (dom, tag, grep) ->
  result = dom.getElementsByTagName(tag)
  elements = []
  for element in result.length
    continue  if grep and not grep(element)
    elements.push result[i]
  elements

proto.normalizeDomWhitespace = (dom) ->
  for tag in [ "span", "strong", "em", "strike", "del", "tt" ]
    for element in dom.getElementsByTagName(tag)
      @normalizePhraseWhitespace element
  @normalizeNewlines dom, [ "br", "blockquote" ], "nextSibling"
  @normalizeNewlines dom, [ "p", "div", "blockquote" ], "firstChild"

proto.normalizeNewlines = (dom, tags, relation) ->
  for tag in tags
    for node in dom.getElementsByTagName(tag)
      next_node = node[relation]
      if next_node and next_node.nodeType == "3"
        next_node.nodeValue = next_node.nodeValue.replace(/^\n/, "")

proto.normalizePhraseWhitespace = (element) ->
  return  if @elementHasComment(element)
  if element.innerHTML == ""
    element.parentNode.removeChild element
    return
  first_node = @getFirstTextNode(element)
  prev_node = @getPreviousTextNode(element)
  last_node = @getLastTextNode(element)
  next_node = @getNextTextNode(element)
  if Wikiwyg.is_gecko and element.tagName == "SPAN"
    tmp = element.innerHTML
    element.innerHTML = tmp.replace(/<br>$/i, "")
  return  if @destroyPhraseMarkup(element)
  if first_node and first_node.nodeValue.match(/^ /)
    first_node.nodeValue = first_node.nodeValue.replace(/^ +/, "")
    prev_node.nodeValue = prev_node.nodeValue + " "  if prev_node and not prev_node.nodeValue.match(RegExp(" $"))
  if last_node and last_node.nodeValue.match(RegExp(" $"))
    last_node.nodeValue = last_node.nodeValue.replace(RegExp(" $"), "")
    next_node.nodeValue = " " + next_node.nodeValue  if next_node and not next_node.nodeValue.match(/^ /)

proto.elementHasComment = (element) ->
  node = element.lastChild
  node and (node.nodeType == 8)

proto.end_is_no_good = (element) ->
  last_node = @getLastTextNode(element)
  next_node = @getNextTextNode(element)
  n = element
  
  while n and n.nodeType != 3
    return false  if n.nodeType == 8
    n = n.lastChild
  return true  unless last_node
  return false  if last_node.nodeValue.match(RegExp(" $"))
  return false  if not next_node or next_node.nodeValue == "\n"
  not next_node.nodeValue.match(Wikiwyg.Wikitext.phrase_end_re)

proto.destroyElement = (element) ->
  try
    range = element.ownerDocument.createRange()
    range.selectNode element
    docfrag = range.createContextualFragment(element.innerHTML)
    element.parentNode.replaceChild docfrag, element
    return true
  catch e
    return false

proto.getFirstTextNode = (element) ->
  node = element
  while node and node.nodeType != 3
    node = node.firstChild
  node

proto.getLastTextNode = (element) ->
  node = element
  while node and node.nodeType != 3
    node = node.lastChild
  node

proto.getPreviousTextNode = (element) ->
  node = element.previousSibling
  node = null  if node and node.nodeType != 3
  node

proto.getNextTextNode = (element) ->
  node = element.nextSibling
  node = null  if node and node.nodeType != 3
  node

proto.skip = ->
  ""

proto.pass = (element) ->
  element.wikitext

proto.handle_undefined = proto.skip
proto.format_abbr = proto.pass
proto.format_acronym = proto.pass
proto.format_address = proto.pass
proto.format_applet = proto.skip
proto.format_area = proto.skip
proto.format_basefont = proto.skip
proto.format_base = proto.skip
proto.format_bgsound = proto.skip
proto.format_big = proto.pass
proto.format_blink = proto.pass
proto.format_body = proto.pass
proto.format_button = proto.skip
proto.format_caption = proto.pass
proto.format_center = proto.pass
proto.format_cite = proto.pass
proto.format_col = proto.pass
proto.format_colgroup = proto.pass
proto.format_dd = proto.pass
proto.format_dfn = proto.pass
proto.format_dl = proto.pass
proto.format_dt = proto.pass
proto.format_embed = proto.skip
proto.format_field = proto.skip
proto.format_fieldset = proto.skip
proto.format_font = proto.pass
proto.format_form = proto.pass
proto.format_frame = proto.skip
proto.format_frameset = proto.skip
proto.format_head = proto.skip
proto.format_html = proto.pass
proto.format_iframe = proto.pass
proto.format_input = proto.skip
proto.format_ins = proto.pass
proto.format_isindex = proto.skip
proto.format_label = proto.skip
proto.format_legend = proto.skip
proto.format_link = proto.skip
proto.format_map = proto.skip
proto.format_marquee = proto.skip
proto.format_meta = proto.skip
proto.format_multicol = proto.pass
proto.format_nobr = proto.skip
proto.format_noembed = proto.skip
proto.format_noframes = proto.skip
proto.format_nolayer = proto.skip
proto.format_noscript = proto.skip
proto.format_nowrap = proto.skip
proto.format_object = proto.skip
proto.format_optgroup = proto.skip
proto.format_option = proto.skip
proto.format_param = proto.skip
proto.format_select = proto.skip
proto.format_small = proto.pass
proto.format_spacer = proto.skip
proto.format_style = proto.skip
proto.format_script = proto.skip
proto.format_sub = proto.pass
proto.format_submit = proto.skip
proto.format_sup = proto.pass
proto.format_textarea = proto.skip
proto.format_tfoot = proto.pass
proto.format_thead = proto.pass
proto.format_wiki = proto.pass
proto.format_www = proto.skip
proto.check_style_for_attribute = (style, attribute) ->
  string = @squish_style_object_into_string(style)
  string.match "\\b" + attribute + "\\b"

proto._for_interesting_attributes = (cb) ->
  cb "fontWeight", "font-weight"
  cb "fontStyle", "font-style"
  cb "textDecoration", "text-decoration"

proto.squish_style_object_into_string = (style) ->
  return  unless style
  return style  if typeof style == "string"
  string = ""
  @_for_interesting_attributes (js, css) ->
    string += css + ": " + style[js] + "; "  if style[js]
  
  string

proto.href_is_wiki_link = (href) ->
  return true  unless @looks_like_a_url(href)
  href = location.href  if href.match(/\/static\//) and href.match(/\/skin\/js-test\//)
  up_to_wksp = /^https?:\/\/([^:\/]+)[^\/]*\/(?!(?:nlw|challenge|data|feed|js|m|settings|soap|st|wsdl)\/)[^\/#]+\//
  no_page_input = href.match(up_to_wksp)
  return false  unless no_page_input
  return false  unless no_page_input[1].toLowerCase() == location.hostname.toLowerCase()
  query = href.split("?")[1]
  return true  unless query
  (not query.match(RegExp("="))) or query.match(/action=display\b/)

proto.looks_like_a_url = (string) ->
  string.match /^(http|https|ftp|irc|mailto|file):/

proto.destroyPhraseMarkup = (element) ->
  return false  if @contain_widget_image(element)
  return @destroyElement(element)  if @start_is_no_good(element) or @end_is_no_good(element)
  false

proto.contain_widget_image = (element) ->
  for e in element.childNodes
    if e.nodeType == 1 and e.nodeName == "IMG"
      if /^st-widget-/.test(e.getAttribute("alt"))
        return true
  false

proto.markupRules =
  italic: [ "bound_phrase", "_", "_" ]
  underline: [ "bound_phrase", "", "" ]
  h1: [ "start_line", "^ " ]
  h2: [ "start_line", "^^ " ]
  h3: [ "start_line", "^^^ " ]
  h4: [ "start_line", "^^^^ " ]
  h5: [ "start_line", "^^^^^ " ]
  h6: [ "start_line", "^^^^^^ " ]
  www: [ "bound_phrase", "\"", "\"<http://...>" ]
  attach: [ "bound_phrase", "{file: ", "}" ]
  image: [ "bound_phrase", "{image: ", "}" ]
  video: [ "bound_phrase", "{video: ", "}" ]
  widget: [ "bound_phrase", "{widget: ", "}" ]
  link: ['bound_phrase', '[', ']'],
  bold: ['bound_phrase', '*', '*'],
  code: ['bound_phrase', '`', '`'],
  strike: ['bound_phrase', '-', '-'],
  p: ['start_lines', ''],
  pre: ['start_lines', '    '],
  ordered: ['start_lines', '#'],
  unordered: ['start_lines', '*'],
  indent: ['start_lines', '>'],
  hr: ['line_alone', '----'],

proto.config.markupRules[k] = v for k, v of proto.markupRules

proto.canonicalText = ->
  wikitext = @getTextArea()
  wikitext += "\n"  unless wikitext[wikitext.length - 1] == "\n"
  @convert_tsv_sections wikitext

proto.convert_tsv_sections = (text) ->
  self = this
  text.replace /^tsv:\s*\n((.*(?:\t| {2,}).*\n)+)/g, (s) ->
    self.detab_table s

proto.detab_table = (text) ->
  text.replace(/\r/g, "").replace(/^tsv:\s*\n/, "").replace(/(\t| {2,})/g, "|").replace(/^/g, "|").replace(/\n/g, "|\n").replace /\|$/, ""

proto.href_label_similar = (elem, href, label) ->
  id_from_href = nlw_name_to_id(href)
  id_from_label = nlw_name_to_id(label)
  id_from_attr = nlw_name_to_id($(elem).attr("wiki_page") or "")
  (id_from_href == id_from_label) or id_from_attr == id_from_label

proto.start_is_no_good = (element) ->
  first_node = @getFirstTextNode(element)
  prev_node = @getPreviousTextNode(element)
  return true  unless first_node
  return false  if first_node.nodeValue.match(/^ /)
  return false  unless prev_node
  return false  if prev_node.nodeValue.match(/^\n?[\xa0\ ]?/)
  return false  if prev_node.nodeValue == "\n"
  not prev_node.nodeValue.match(/[\( "]$/)

proto._is_block_level_node = (node) ->
  node and node.nodeName and node.nodeName.match(/^(?:UL|LI|OL|P|H\d+|HR|TABLE|TD|TR|TH|THEAD|TBODY|BLOCKQUOTE)$/)

proto.build_msoffice_list = (top) ->
  self = this
  (->
    $top = $(top)
    firstHtml = $top.html()
    return  unless firstHtml.match(/<!--\[SocialtextBulletBegin\]-->[\w\W]*?<!--\[SocialtextBulletEnd\]-->/)
    firstHtml = firstHtml.replace(/<!--\[SocialtextBulletBegin\]-->(?:<\w[^>]*>)*([\w\W]*?)<!--\[SocialtextBulletEnd\]-->/, "")
    bulletText = RegExp.$1
    listType = (if bulletText.match(/^\w+\./) then "ol" else "ul")
    cur = top
    newHtml = "<li>" + firstHtml + "</li>"
    toRemove = []
    while cur = $(cur).next("p.ListParagraphCxSpMiddle, p.ListParagraphCxSpLast," + "p.MsoListParagraphCxSpMiddle, p.MsoListParagraphCxSpLast")[0]
      $cur = $(cur)
      continue  if $cur.hasClass("_st_walked")
      if parseInt($cur.css("text-indent") or "0") == 0 and ($cur.text().search(/\S/) == -1)
        toRemove.push $cur
        continue
      topIndent = self._css_to_px($top.css("margin-left")) or 0
      curIndent = self._css_to_px($cur.css("margin-left")) or 0
      if curIndent < topIndent
        break
      else if curIndent > topIndent
        newHtml += self.build_msoffice_list(cur)
      else
        newHtml += "<li>" + $cur.html().replace(/<!--\[SocialtextBulletBegin\]-->[\w\W]*?<!--\[SocialtextBulletEnd\]-->/, "") + "</li>"
      $cur.addClass "_st_walked"
      toRemove.push $cur
    $_.remove() for $_ in toRemove
    "<" + listType + ">" + newHtml + "</" + listType + ">"
  )()

proto.convert_html_to_wikitext = (html, isWholeDocument) ->
  self = this
  return ""  if html == ""
  html = html.replace(/^\s*<div(?:\s*\/|><\/div)>/, "")
  html = @strip_msword_gunk(html)
  (->
    dom = document.createElement("div")
    dom.innerHTML = html
    
    while cur = $(dom).find("p.ListParagraphCxSpFirst:first, p.MsoListParagraphCxSpFirst:first, p.MsoListParagraph:first, p.ListParagraph:first")[0]
      $(cur).replaceWith self.build_msoffice_list(cur)
    $(dom).find("._st_walked").removeClass "_st_walked"
    
    loop
      paragraphs = dom.getElementsByTagName("p")
      len = paragraphs.length
      break  unless len
      foundVisualBR = false
      i = 0
      
      while i < len
        cur = paragraphs[i]
        continue  if cur.className.indexOf("st_walked") >= 0
        if self._css_to_px(cur.style.marginBottom) < 1
          next = self._get_next_node(cur)
          if next and next.nodeType == 1 and next.nodeName == "P"
            cur.style.marginBottom = next.style.marginBottom
            $next = $(next)
            $(cur).append "<br />" + $next.html()
            $next.remove()
            foundVisualBR = true
            break
        cur.className += (if cur.className then " " else "") + "st_walked"
        i++
      break unless foundVisualBR
    $(dom).find("td, hr, pre").parents("span:not(.nlw_phrase), a, h1, h2, h3, h4, h5, h6, b, strong, i, em, strike, del, s, tt, code, kbd, samp, var, u").addClass "_st_format_div"
    $(dom).find("._st_walked").removeClass "_st_walked"
    if Wikiwyg.is_ie
      elems = dom.getElementsByTagName("div")
      i = 0
      l = elems.length
      
      while i < l
        continue  unless elems[i].className == "wiki"
        div = document.createElement("div")
        div.innerHTML = elems[i].innerHTML
        elems[i].parentNode.replaceChild div, elems[i]
        i++
      html = dom.innerHTML
    else
      $dom = $(dom)
      $dom.find("div.wiki").each ->
        html = $(this).html()
        if /<br\b[^>]*>\s*$/i.test(html)
          $(this).replaceWith html
        else
          $(this).replaceWith html + "<br />"
      
      cleanup_newlines = ->
        if @nodeType == 3
          if @previousSibling and @previousSibling.nodeType == 1 and @previousSibling.nodeName != "BR"
            if self._is_block_level_node(@previousSibling)
              @nodeValue = @nodeValue.replace(/^\n/, "")
            else
              @nodeValue = @nodeValue.replace(/^\n/, " ")
          else
            @nodeValue = @nodeValue.replace(/^\n/, "")
          if @nextSibling and @nextSibling.nodeType == 1 and @nextSibling.nodeName != "BR"
            if self._is_block_level_node(@nextSibling)
              @nodeValue = @nodeValue.replace(/\n$/, "")
            else
              @nodeValue = @nodeValue.replace(/\n$/, " ")
          else
            @nodeValue = @nodeValue.replace(/\n$/, "")
          @nodeValue = @nodeValue.replace(/\n/g, " ")
        else $(this).contents().not("iframe").each cleanup_newlines  if $(this).is(":not(pre,plain)")
      
      if isWholeDocument
        contents = $dom.find("div.wiki").contents()
        if contents.length == 0
          $dom.find("iframe").remove()
          contents = $dom.contents()
        if contents.length > 0
          i = 0
          
          while i < contents.length
            firstNode = contents[i]
            continue  if firstNode.nodeType == 1 and firstNode.innerHTML == ""
            firstNode.nodeValue = firstNode.nodeValue.replace(/^\n/, "")  if firstNode.nodeType == 3
            break
            i++
          i = contents.length - 1
          
          while i >= 0
            lastNode = contents[i]
            continue  if lastNode.nodeType == 1 and lastNode.innerHTML == ""
            lastNode.nodeValue = lastNode.nodeValue.replace(/\n$/, "")  if lastNode.nodeType == 3
            break
            i--
          contents.each cleanup_newlines
      else
        $dom.contents().each cleanup_newlines
      html = $dom.html()
  )()
  @copyhtml = html
  dom = document.createElement("div")
  dom.innerHTML = html
  @output = []
  @list_type = []
  @indent_level = 0
  @no_collapse_text = false
  @depth = 0
  @normalizeDomWhitespace dom
  @normalizeDomStructure dom
  @dom = dom
  @walk(dom).replace(/[\xa0\s\n]*$/, "\n").replace /\r/g, ""

proto.walk = (elem) ->
  @depth++
  return ""  unless elem
  part = elem.firstChild
  
  while part
    if part.nodeType == 1
      continue  if @no_descend(part)
      part.wikitext = @walk(part)
    part = part.nextSibling
  @wikitext = ""
  fixups = []
  part = elem.firstChild
  
  while part
    if part.nodeType == 3
      if not (part.nodeValue.match(/[^\n]/) and (not part.nodeValue.match(/^\n[\n\ \t]*$/))) or (part.nodeValue.match(/^\s+$/) and part.previousSibling and part.previousSibling.nodeName == "BR" and part.previousSibling.previousSibling and part.previousSibling.previousSibling.nodeName == "BR")
        node = part
        part = part.nextSibling
        node.parentNode.removeChild node
        continue
    method = "format_" + part.nodeName.toLowerCase()
    method = "format_indent"  if method != "format_blockquote" and part.is_indented
    method = "format_div"  if /\b_st_format_div\b/.test(part.className)
    method = method.replace(/#/, "")
    try
      text = this[method](part)
      if part.fixup
        text = "\u0007" + text + "\u0007"
        fixups.push [ part.fixup, part ]
      unless text
        part = part.nextSibling
        continue
      if @wikitext and @wikitext != "\n"
        node = part
        
        while node
          if node.top_level_block
            len = @wikitext.length
            len--  if @wikitext.charAt(len - 1) == "\n"
            len--  if @wikitext.charAt(len - 1) == "\n"
            while @wikitext.charAt(len - 1) == " "
              len--
            if len == @wikitext.length
              @wikitext += "\n\n"
            else
              @wikitext = @wikitext.substr(0, len) + "\n\n"
            break
          break  if @_is_block_level_node(node)
          node = node.firstChild
      @assert_trailing_space part, text
      @wikitext += text
    part = part.nextSibling
  
  @[fixup[0]](fixup[1]) for fixup in fixups

  @depth--
  return ""  unless (@wikitext.length and @wikitext.match(/\S/))
  @wikitext

proto.assert_trailing_space = (part, text) ->
  return  if (not part.requires_preceding_space) and (not part.previousSibling) or (not part.previousSibling.requires_trailing_space) or (part.nodeName == "BR")
  return  if RegExp(" $").test(@wikitext)
  if /\n$/.test(@wikitext)
    return  if part.previousSibling and (part.previousSibling.nodeName == "BR" or part.previousSibling.nodeName == "HR")
    return  if part.top_level_block
    @wikitext = @wikitext.replace(/\n$/, "")
  return  if /^\s/.test(text)
  if part.top_level_block
    @wikitext += "\n"
  else
    @wikitext += " "

proto._css_to_px = (val = "") ->
  if val.match(/^-?([\.\d]+)px/)
    return Number(RegExp.$1)
  else if val.match(/^-?([\.\d]+)in/)
    return Number(RegExp.$1) * 80
  else if val.match(/^-?([\.\d]+)cm/)
    return Number(RegExp.$1) * 28
  else if val.match(/^-?([\.\d]+)em/)
    return Number(RegExp.$1) * 10
  else if val.match(/^-?([\.\d]+)ex/)
    return Number(RegExp.$1) * 6
  else return Number(RegExp.$1) * 4 / 3  if val.match(/^-?([\.\d]+)pt/)
  undefined

proto.no_descend = (elem) ->
  if elem.nodeName == "BLOCKQUOTE"
    elem.is_indented = true
  else if elem.nodeName.match(/^(P|DIV)$/)
    indent = @_css_to_px(elem.style.marginLeft)
    elem.is_indented = indent  unless indent == undefined
  Boolean (elem.nodeName.match(/^(DIV|SPAN)$/) and elem.className.match(/^(nlw_phrase|wafl_block)$/)) or (elem.nodeName == "A" and elem.lastChild and elem.lastChild.nodeType == 8) or (elem.nodeName == "A") or (elem.nodeName == "SPAN") and @get_wiki_comment(elem)

proto.check_start_of_block = (elem) ->
  prev = elem.previousSibling
  next = elem.nextSibling
  @wikitext += "\n"  if @wikitext and prev and prev.top_level_block and not /\n\n$/.test(@wikitext) and not (elem.nodeType == 3) and (not /\S/.test(elem.nodeValue)) and (next and next.nodeName == "BR") and (/\n$/.test(@wikitext) or next.nextSibling and next.nextSibling.nodeName == "BR")

proto._get_next_node = (elem) ->
  return elem  unless elem
  if elem.nextSibling
    return @_get_next_node(elem.nextSibling)  if elem.nextSibling.nodeType == 3 and elem.nextSibling.nodeValue.match(/^[\xa0\s]*$/)
    return elem.nextSibling
  @_get_next_node elem.parentNode

proto.format_text = (elem) ->
  elem.top_level_block = true  if elem.previousSibling and elem.previousSibling.nodeName == "P" and elem.previousSibling.wikitext == ""
  @check_start_of_block elem
  text = elem.nodeValue.replace(/^\n+/, "").replace(/[\xa0 ]+/g, " ")
  if text.match(/^[\xa0\s]+$/)
    next = @_get_next_node(elem)
    return ""  unless next
    return ""  if next.nodeType == 1 and (next.nodeName == "BR" or @_is_block_level_node(next))
  text = text.replace(/^\s+/, "")  if text.match(/^\s+/) and elem.previousSibling and elem.previousSibling.nodeType == 1 and elem.previousSibling.nodeName == "BR"
  text = text.replace(/\s+$/, "")  if text.match(/\s+$/) and elem.nextSibling and elem.nextSibling.nodeType == 1 and elem.nextSibling.nodeName == "BR"
  text = text.replace(/\xa0 /g, " ")
  text = text.replace(/\xa0/g, " ")
  text

proto.format_div = (elem) ->
  if elem.className == "nlw_phrase"
    elem.top_level_block = true
    return @handle_nlw_phrase(elem)
  return @handle_wafl_block(elem)  if elem.className == "wafl_block"
  text = elem.wikitext
  text.replace(/^\s+$/, "").replace /\n*$/, "\n"

proto.handle_nlw_phrase = (elem) ->
  @check_start_of_block elem
  comment = elem.lastChild
  text = Wikiwyg.htmlUnescape(comment.nodeValue).replace(/^\ wiki: ([\s\S]*?)\ ?$/, "$1").replace(/\n*$/, "").replace(/-=/g, "-").replace(RegExp("==", "g"), "=")
  elem.is_widget = true
  prev = elem.previousSibling
  elem.widget_on_widget = true  if prev and prev.nodeName == "BR" and prev.previousSibling and prev.previousSibling.is_widget
  @handle_include text, elem

proto.handle_wafl_block = (elem) ->
  comment = elem.lastChild
  return  unless comment
  text = comment.data
  text = text.replace(/^ wiki:\s+/, "").replace(/-=/g, "-").replace(RegExp("==", "g"), "=")
  elem.top_level_block = true
  text

proto.format_p = (elem) ->
  if elem.className == "padding" and not @wikitext
    return "\n"  if Wikiwyg.is_ie
    return
  text = elem.wikitext
  elem.top_level_block = true
  unless text
    return "\n"  if Wikiwyg.is_ie and elem == elem.parentNode.lastChild
    return
  return  if text == " "
  text + "\n"

proto.format_img = (elem) ->
  widget = elem.getAttribute("alt")
  if /^st-widget-/.test(widget)
    widget = widget.replace(/^st-widget-/, "")
    widget = Wikiwyg.htmlUnescape(widget)  if Wikiwyg.is_ie
    if $.browser.webkit
      widget = widget.replace(/&#x([a-fA-F\d]{2,5});/g, ($_, $1) ->
        String.fromCharCode parseInt($1, 16)
      )
    if widget.match(/^\.[-\w]+\n/)
      elem.top_level_block = true
    else
      elem.is_widget = true
    @check_start_of_block elem
    text = widget.replace(/-=/g, "-").replace(RegExp("==", "g"), "=")
    prev = elem.previousSibling
    requires_preceding_space = false
    unless text.match(/\{\{.*\}\}/)
      elem.requires_trailing_space = true  unless elem.top_level_block
      if prev and not (prev.nodeType == 1 and prev.nodeName == "BR") and not prev.top_level_block
        if prev.nodeType == 3 and Wikiwyg.is_ie
          elem.requires_preceding_space = true
        else
          prev.requires_trailing_space = true
    text = @handle_include(text, elem)
    text = text.replace(/\n*$/, "\n")  if widget.match(/^\.[-\w]+\n/)
    elem.requires_trailing_space = true  unless text.match(/\{\{\{.*\}\}/)  if Wikiwyg.is_ie
    elem.widget_on_widget = true  if prev and prev.nodeName == "BR" and prev.previousSibling and prev.previousSibling.is_widget
    return text
  uri = elem.getAttribute("src")
  if uri
    @check_start_of_block elem
    uri

proto.handle_include = (text, elem) ->
  if text.match(/^{include:/)
    if not @wikitext or @wikitext.match(/\n$/)
      next = elem.nextSibling
      if next
        next.nodeValue = next.nodeValue.replace(/^\s*/, "")  if next.nodeType == 3 and next.nodeValue.match(/\S/)
        next.wikitext = next.wikitext.replace(/^\s*/, "")  if next.nodeType == 1
    @is_include = true
    elem.requires_trailing_space = null
  text

proto._format_one_line = (elem) ->
  style = @squish_style_object_into_string(elem.style)
  if not style or style == ""
    if (elem.parentNode.nodeName == "P") and (elem.parentNode.className == "MsoNormal")
      
    else
      return elem.wikitext
  elem.wikitext = elem.wikitext.replace(/\n/g, " ").replace(RegExp("  *", "g"), " ")
  elem.wikitext = @format_b(elem)  if style.match(/font-weight: bold;/)
  elem.wikitext = @format_i(elem)  if style.match(/font-style: italic;/)
  elem.wikitext = @format_strike(elem)  if style.match(/text-decoration: line-through;/)
  elem.wikitext

proto.format_span = (elem) ->
  return @handle_nlw_phrase(elem)  if (elem.className == "nlw_phrase") or @get_wiki_comment(elem)
  @_format_one_line elem

proto.format_indent = (elem) ->
  px = elem.is_indented
  while px > 0
    elem.wikitext = @format_blockquote(elem)
    px -= 40
  elem.wikitext

proto.format_blockquote = (elem) ->
  unless (elem.parentNode.is_indented or (elem.previousSibling and elem.previousSibling.is_indented))
    elem.top_level_block = true
  else
    @wikitext = @wikitext.replace(RegExp(" $"), "")
    @wikitext += "\n"  if @wikitext and not @wikitext.match(/\n$/)
  elem.wikitext.replace(/^[>]/g, ">>").replace(/^([^>])/g, "> $1").replace(RegExp(" *$", "g"), "").replace /\n*$/, "\n"

proto.format_li = (elem) ->
  "\u0007" + elem.wikitext.replace(/^\xa0$/, "").replace(/^\s*/, "").replace(/\n+/g, " ").replace(RegExp("  +"), " ").replace(RegExp(" *$"), "") + "\n"

proto.format_ul = (elem) ->
  elem.top_level_block = true  unless elem.parentNode.nodeName.match(/^(UL|OL)$/)
  text = elem.wikitext.replace(/^([*]+)( |$)/g, "*$1$2").replace(/^([#]+)( |$)/g, "#$1$2").replace(/^\x07$/g, "*").replace(/^\x07(?=.)/g, "* ")
  text

proto.format_ol = (elem) ->
  elem.top_level_block = true  unless elem.parentNode.nodeName.match(/^(UL|OL)$/)
  text = elem.wikitext.replace(/^([*]+)( |$)/g, "*$1$2").replace(/^([#]+)( |$)/g, "#$1$2").replace(/^\x07$/g, "#").replace(/^\x07(?=.)/g, "# ")
  text

proto.format_table = (elem) ->
  elem.top_level_block = true
  options = $(elem).attr("options")
  (if options then "|| " + options + "\n" else "") + elem.wikitext

proto.format_tr = (elem) ->
  elem.wikitext + "|\n"

proto.format_td = (elem) ->
  if elem.firstChild and elem.firstChild.nodeName.match(/^(H[123456])$/)
    elem.wikitext = elem.wikitext.replace(/\n?$/, "\n")  unless elem.wikitext == ""
    return "| " + elem.wikitext
  if elem.firstChild and elem.firstChild.nodeName.match(/^(OL|UL|BLOCKQUOTE)$/)
    elem.wikitext = "\n" + elem.wikitext.replace(/\n$/, " ")
    return "| " + elem.wikitext
  if elem.wikitext.match(/\n/) or (elem.firstChild and elem.firstChild.top_level_block)
    elem.wikitext = elem.wikitext.replace(/\s?\n?$/, " ")
    return "| " + elem.wikitext
  else
    style = @squish_style_object_into_string(elem.getAttribute("style"))
    elem.wikitext = @format_b(elem)  if style and style.match(/font-weight: bold;/)
    elem.wikitext = @format_i(elem)  if style and style.match(/font-style: italic;/)
    elem.wikitext = @format_strike(elem)  if style and style.match(/text-decoration: line-through;/)
  "| " + elem.wikitext + " "

proto.format_th = proto.format_td
proto.format_tbody = (elem) ->
  elem.wikitext

i = 1

while i <= 6
  padding = " "
  j = 1
  
  while j <= i
    padding = "^" + padding
    j++
  ((p) ->
    proto["format_h" + i] = (elem) ->
      elem.top_level_block = true
      text = @_format_one_line(elem)
      return ""  if text == ""
      text = p + text
      text.replace /\n*$/, "\n"
  ) padding
  i++
proto.format_pre = (elem) ->
  data = Wikiwyg.htmlUnescape(elem.innerHTML)
  data = data.replace(/<br>/g, "\n").replace(/\r?\n$/, "").replace(/^&nbsp;$/, "\n")
  elem.top_level_block = true
  ".pre\n" + data + "\n.pre\n"

proto.format_a = (elem) ->
  return ""  if elem.innerHTML == ""
  if elem.childNodes.length == 1 and elem.childNodes[0].nodeType == 1
    additional_styles = elem.childNodes[0].getAttribute("style")
    if additional_styles
      if (additional_styles.constructor + "").match("String")
        elem.setAttribute "style", elem.getAttribute("style") + ";" + additional_styles
      else
        @_for_interesting_attributes (js) ->
          elem.style[js] = additional_styles[js]  if additional_styles[js]
  @check_start_of_block elem
  label = elem.innerHTML
  label = label.replace(/<[^>]*>/g, " ")
  label = Wikiwyg.htmlUnescape(label)
  label = label.replace(/\s+/g, " ").replace(/^\s+/, "").replace(/\s+$/, "")
  href = elem.getAttribute("href")
  href = href.replace(/^(?:\.\.\/)+/, location.protocol + "//" + location.hostname + (if (location.port == 80) or (location.port == "") then "" else ":" + location.port) + "/")
  href = ""  unless href
  link = @make_wikitext_link(label, href, elem)
  if /^[\[{]/.test(link)
    prev_node = @getPreviousTextNode(elem)
    link = " " + link  if prev_node and prev_node.nodeValue.match(/\w$/)
    next_node = @getNextTextNode(elem)
    link = link + " "  if next_node and next_node.nodeValue.match(/^\w/)
  elem.fixup = "strip_ears"
  elem.wikitext = link
  @_format_one_line elem

proto.strip_ears = (elem) ->
  self = this
  @wikitext = @wikitext.replace(/(^|[\s\S])\x07([^\x07]*)\x07([\s\S]|$)/, ($0, $1, $2, $3) ->
    link = $2
    return $1 + link + $3  if link.match(/\s/)
    return $1 + link  if self.is_italic(elem.parentNode)  if self.wikitext.match(/>\x07$/)
    link = link.replace(/^<(.*)>$/, "$1")  if (not ($1.match(/\S/) or $3.match(/\S/))) or ($1 == "'" and not $3.match(/\S/))
    $1 + link + $3
  )

proto.is_italic = (elem) ->
  self = this
  elem and (elem.nodeName == "I" or elem.nodeName == "EM" or (elem.nodeName == "SPAN" and ((elem) ->
    style = ""
    try
      style = self.squish_style_object_into_string(elem.getAttribute("style"))
    /font-style: italic;/.test style
  )(elem)))

proto.elem_is_wiki_link = (elem, href) ->
  href = href or elem.getAttribute("href") or ""
  $(elem).attr("wiki_page") or @href_is_wiki_link(href)

proto.make_wikitext_link = (label, href, elem) ->
  mailto = href.match(/^mailto:(.*)/)
  if @elem_is_wiki_link(elem, href)
    @handle_wiki_link label, href, elem
  else if mailto
    address = mailto[1]
    address = address.replace(/\%25/g, "%")  if Wikiwyg.is_ie and $.browser.version == 6
    if address == label
      address
    else
      "\"" + label + "\"<" + href + ">"
  else
    if href == label
      "<" + href + ">"
    else if @looks_like_a_url(label)
      "<" + label + ">"
    else
      "\"" + label + "\"<" + href + ">"

proto.handle_wiki_link = (label, href, elem) ->
  up_to_wksp = /^https?:\/\/[^\/]+\/([^\/#]+)\/(?:(?:index.cgi)?\?)?/
  match = href.match(up_to_wksp)
  wksp = (if match then match[1] else Socialtext.wiki_id)
  href_orig = href
  is_incipient = false
  if /.*\baction=display;is_incipient=1;page_name=/.test(href)
    is_incipient = true
    href = href.replace(/.*\baction=display;is_incipient=1;page_name=/, "")
  href = href.replace(up_to_wksp, "")
  href = decodeURIComponent(href)
  href = href.replace(/_/g, " ")
  wiki_page = $(elem).attr("wiki_page")
  prefix = ""
  page = ""
  if label == href_orig and (label.indexOf("=") == -1)
    page = wiki_page or href
  else if @href_label_similar(elem, href, label)
    page = wiki_page or label
  else
    page = wiki_page or href
    prefix = "\"" + label + "\""
  if /#/.test(page) and (page == href) and not is_incipient
    segments = page.split(/#/, 2)
    section = segments[1]
    page = segments[0]
    prefix + "{link: " + wksp + " [" + page + "] " + section + "}"
  else unless wksp == Socialtext.wiki_id
    prefix + "{link: " + wksp + " [" + page + "]}"
  else
    prefix + "[" + page + "]"

proto.COMMENT_NODE_TYPE = 8
proto.get_wiki_comment = (elem) ->
  node = elem.firstChild
  
  while node
    return node  if node.nodeType == @COMMENT_NODE_TYPE and node.data.match(/^\s*wiki/)
    node = node.nextSibling
  null

proto.format_br = (elem) ->
  return @format_hr(elem)  if elem.style.pageBreakBefore == "always"
  @wikitext = @wikitext.replace(/\xA0/, "")  if Wikiwyg.is_ie
  "\n"

proto.format_hr = (elem) ->
  return ""  if @has_parent(elem, "LI")
  "----\n"

proto.has_parent = (elem, name) ->
  while elem = elem.parentNode
    return true  if elem.nodeName == name
  false

build_bound_phrase_formatter = (style) ->
  (elem) ->
    @check_start_of_block elem
    markup = @config.markupRules[style]
    markup_open = markup[1]
    markup_close = markup[2] or markup_open
    wikitext = elem.wikitext
    prev_node = elem.previousSibling
    if prev_node and prev_node.nodeType == 3
      if prev_node.nodeValue.match(/\w$/) and wikitext.match(/^\S/)
        return wikitext
      else wikitext = wikitext.replace(/^\s+/, "")  if prev_node.nodeValue.match(/\s$/)
    next_node = elem.nextSibling
    if next_node and next_node.nodeType == 3
      if next_node.nodeValue.match(/^\w/) and wikitext.match(/\S$/)
        return wikitext
      else wikitext = wikitext.replace(/\s+$/, "")  if next_node.nodeValue.match(/^\s/)
    return wikitext  unless (/\S/.test(wikitext))
    wikitext.replace(/^(\s*)/, "$1" + markup_open).replace(/(\s*)$/, markup_close + "$1").replace /\n/g, " "

style_of =
  b: "bold"
  strong: "bold"
  i: "italic"
  em: "italic"
  strike: "strike"
  del: "strike"
  s: "strike"
  tt: "code"
  code: "code"
  kbd: "code"
  samp: "code"
  var: "code"
  u: "underline"

for tag, style of style_of
  proto["format_" + tag] = build_bound_phrase_formatter(style)
